

;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	   Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 90-AA7F-B8D1-F8			    |
; |				 Licensed User				    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	400C4CFF6E2E04BCDB354891853798D2

; File Name   :	D:\Sega\Dev\Disasms\Thunder Force IV\Z80Driver.bin
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 2000h Loaded length: 2000h

; Processor	  : z80	[]
; Target assembler: Zilog Macro	Assembler

; ===========================================================================

; Segment type:	Pure code
		segment	ROM
		db 0C3h
		db 3Ch
DAC_Playing:	db 0				; DATA XREF: ROM:00C8w
						; PlayPCM+Fw ...
Command:	db 4Fh				; DATA XREF: ROM:MainLoopr
						; ROM:00ECw ...
Input:		db 0, 0, 0, 0			; DATA XREF: SwapEndianesso
						; LoadSFXr ...
SampleID:	db 0				; DATA XREF: ROM:018Ar
						; ROM:0193w ...
		db 0
byte_A:		db 0				; DATA XREF: ROM:134Aw
						; ROM:FlagE7r ...
BusyFlag:	db 0				; DATA XREF: Write_YM_Port0+Aw
						; Write_YM_Port0+18w ...
byte_C:		db 0				; DATA XREF: SetFM_Pan_AMS_FMS+9r
		db 0
BGM_LoopFlag:	db 0				; DATA XREF: ROM:0D14w
						; UpdateBGMChannel+75r
CurrentChannel:	db 0				; DATA XREF: SendChannelKeyEventr
						; sub_306+17w ...
u_ChanNum:	dw 0				; DATA XREF: u_FM_PlayNote+4r
						; sub_6A3+84r ...
FadeOutSpeed:	db 0				; DATA XREF: DriverInterrupt+55r
						; ROM:0DD1w ...
FadeOutCounter:	db 0				; DATA XREF: DriverInterrupt+5Bo
						; ROM:0DD4w
FadeOutVolume:	db 0				; DATA XREF: SetChannelVolume+1Ar
						; DriverInterrupt+62o ...
byte_15:	db 0				; DATA XREF: InitBGMPlayback+29w
						; ROM:1392r ...
byte_16:	db 0				; DATA XREF: SetChannelVolume+90r
						; FlagE2_u_PSGEffect-D17w ...
BGM_Volume:	db 0				; DATA XREF: InitBGMPlayback+Cw
						; u_PlayNote+2Dr
BGM_Tempo:	db 0				; DATA XREF: InitBGMPlayback+11w
						; InitBGMPlayback+19r ...
BGM_Pitch:	db 0				; DATA XREF: InitBGMPlayback+16w
						; u_PlayNote+Br
u_LFO_Byte:	db 0				; DATA XREF: u_FM_PlayNote+10o
						; LoadInstrument-140w ...
		db 0
byte_1C:	db 0				; DATA XREF: u_FM_PlayNote+Ar
						; u_FM_PlayNote+28r ...
byte_1D:	db 0				; DATA XREF: u_FM_PlayNote+1Fw
						; sub_8AF+17r ...
		db 0
		db 0
BGM_ChannelsPlaying:dw 0			; DATA XREF: ROM:00A5w
						; sub_306+Dr ...
SFX_ChannelsPlaying:dw 0			; DATA XREF: ROM:00A8w
						; RestoreFM6_Pan_AMS_FMS+Br ...
		db 0
		db 0
		db 0
		db 0
		db 0
word_29:	dw 0				; DATA XREF: u_FM_PlayNote+3Aw
						; sub_A54+1Er ...
word_2B:	dw 0				; DATA XREF: u_FM_PlayNote+22r
						; LoadInstrument-134w ...
byte_2D:	db 0				; DATA XREF: u_FM_PlayNote:loc_609w
						; sub_A54r ...
word_2E:	dw 0				; DATA XREF: u_FM_PlayNote+3Dw
		db 0
		db 0
byte_32:	db 0				; DATA XREF: u_FM_PlayNote+37w
						; sub_A54:loc_A64r ...
		db 0
		db 0
		db 0
u_PCM_Data_Copy:dw 0				; DATA XREF: ROM:007Ew
						; ROM:0082w

; =============== S U B	R O U T	I N E =======================================

; Attributes: thunk

j_DriverInterrupt:
		jp	DriverInterrupt
; End of function j_DriverInterrupt

; ---------------------------------------------------------------------------
		db    0
; ---------------------------------------------------------------------------

InitDriver:
		di
		im	1
		ld	sp, Stack
; Setup	bank 78000h
		ld	a, 1
		ld	(BankRegister),	a
		ld	(BankRegister),	a
		ld	(BankRegister),	a
		ld	(BankRegister),	a
		xor	a
		ld	(BankRegister),	a
		ld	(BankRegister),	a
		ld	(BankRegister),	a
		ld	(BankRegister),	a
		ld	(BankRegister),	a
		ld	hl, PCM_Data
		ld	de,  PCM_Data+1
		ld	bc, 606h
		ld	(hl), 0
		ldir
		ld	hl, 700h
		ld	de, 80h
		ld	(u_MusicBankOffset), hl
		ld	(ROM_Offset2+1), de
		ld	hl, PCM_Data
		ld	a, h
		ld	(u_PCM_Data_Copy), a
		ld	a, l
		ld	(u_PCM_Data_Copy+1), a
		ld	a, 6Eh
		call	SetTimerB
		ld	h, 24h
		ld	a, 52h
		call	Write_YM_Port0		; h = Register,	a = Value
		inc	h
		ld	a, 3
		call	Write_YM_Port0		; h = Register,	a = Value
		ld	h, 27h
		xor	a
		call	Write_YM_Port0		; h = Register,	a = Value
		ld	a, 3Fh
		call	Write_YM_Port0		; h = Register,	a = Value
		xor	a
		ld	h, a
		ld	l, h
		ld	(BGM_ChannelsPlaying), hl
		ld	(SFX_ChannelsPlaying), hl
		ld	(hl), 0FFh
		ld	hl, 8000h
		ld	(Offset_BGM), hl
		ld	hl, 0F000h
		ld	(Offset_SFX), hl
		ld	a, 63h
		ld	(u_OffsetByte),	a
		ld	(u_OffsetByte2), a
		call	InitPSG
		ei
		ld	hl, 0
		ld	(DAC_Playing), hl	; clear	DAC playing flag and command

MainLoop:					; CODE XREF: ROM:00D4j
						; ROM:loc_EFj
						; DATA XREF: ...
		ld	a, (Command)
		or	a
		jr	nz, ExecCommand
		call	TimeredInterrupts
		jr	MainLoop
; ---------------------------------------------------------------------------

ExecCommand:					; CODE XREF: ROM:00CFj
		cp	0Eh			; is command >=	0Eh?
		jr	nc, IdleCommand		; if yes, branch
		ld	e, a
		ld	d, 0			; de = Command
		ld	hl, CommandsTable
		add	hl, de
		add	hl, de			; hl = CommandsTable + Command*2
		ld	a, (hl)			; load command offset from the table
		inc	hl			; ''
		ld	h, (hl)			; ''
		ld	l, a
		ld	de, MainLoop
		push	de			; push return address
		jp	(hl)			; jump to command's routine
; ---------------------------------------------------------------------------

IdleCommand:					; CODE XREF: ROM:00D8j
		xor	a
		ld	(Command), a

loc_EF:
		jr	MainLoop
; ---------------------------------------------------------------------------
CommandsTable:	dw ResetCommand			; DATA XREF: ROM:00DDo
		dw LoadBGM2			; 01h
		dw LoadSFX			; 02h
		dw FadeOutBGM			; 03h
		dw u_StopSFX			; 04h
		dw PlayVoice			; 05h
		dw ResetCommand			; 06h
		dw u_FetchOffset		; 07h
		dw u_FetchOffset2		; 08h
		dw LoadBGM			; 09h
		dw LoadSoundBank		; 0Ah
		dw PlayVoice2			; 0Bh
		dw PauseMusic			; 0Ch
		dw PlayVoice3			; 0Dh
; ---------------------------------------------------------------------------

PauseMusic:					; DATA XREF: ROM:CommandsTableo
		di
		ld	bc, WriteFMData_NoTest	; Perhaps lack of testing means	SFX or when SFX	isn't playing
		ld	(loc_470+1), bc		; this offset is dynamic!
		ld	bc, WritePSGData_NoTest	; Perhaps lack of testing means	SFX or when SFX	isn't playing
		ld	(loc_42A+1), bc		; this offset is dynamic!
		ld	(loc_45E+1), bc		; this offset is dynamic!
		ld	(loc_464+1), bc		; this offset is dynamic!
		xor	a			; volume level?
		ld	c, 3			; force	'key off' event, channels > FM3?
		call	sub_306			; something to do about	SFX/BGM	simulateous processing
		call	WaitUnpauseCommand
		xor	a
		ld	(Command), a		; clear	command
		ld	a, 0FFh			; volume level?
		ld	c, 0F3h			; force	'key on' event, channels > FM3?
		call	sub_306			; something to do about	SFX/BGM	simulateous processing
		ld	bc, WriteFMData		; h = Register,	a = Value
		ld	(loc_470+1), bc		; this offset is dynamic!
		ld	bc, WritePSGData	; a = Data
		ld	(loc_42A+1), bc		; this offset is dynamic!
		ld	(loc_45E+1), bc		; this offset is dynamic!
		ld	(loc_464+1), bc		; this offset is dynamic!
		ei
		ret

; =============== S U B	R O U T	I N E =======================================


WaitUnpauseCommand:				; CODE XREF: ROM:012Ap
						; WaitUnpauseCommand+Cj ...
		xor	a
		ld	(Command), a		; clear	command

WaitCommandLoop:				; CODE XREF: WaitUnpauseCommand+8j
		ld	a, (Command)		; load command
		or	a			; test it
		jr	z, WaitCommandLoop	; if it's zero, loop
		cp	0Ch			; is this command 0Ch (pause/unpause?)
		jr	nz, WaitUnpauseCommand	; if not, branch
		ret
; End of function WaitUnpauseCommand

; ---------------------------------------------------------------------------

PlayVoice:					; DATA XREF: ROM:CommandsTableo
		di
		call	DisableFM6
		ld	hl, 4			; how the fuck???
		call	PlayPCM			; hl = PCM Data	offset
		call	RestoreFM6
		ei
		ret
; ---------------------------------------------------------------------------

PlayVoice2:					; DATA XREF: ROM:CommandsTableo
		di
		call	DisableFM6
		ld	hl,  Input+1
		call	LoadBank		; (hl) = Bank offset (Big Endian)
		ld	hl, PCM_Data
		call	PlayPCM			; hl = PCM Data	offset
		call	DoBankSwitch
		call	RestoreFM6
		ei
		ret
; ---------------------------------------------------------------------------

PlayVoice3:					; DATA XREF: ROM:CommandsTableo
		di
		call	DisableFM6
		ld	a, (SampleID)
		cp	9
		jr	c, LoadSampleBank
		sub	9
		ld	(SampleID), a
; The following	code calculates	next bank's offset
		ld	a, (Input+2)		; load bank offset's low byte
		add	a, 80h			; add 8000h to it
		ld	(Input+2), a		; save it
		jr	nc, LoadSampleBank	; if no	carry occured, branch
		ld	a, (Input+1)		; load bank's offset high byte
		inc	a			; increase it
		ld	(Input+1), a		; save it

LoadSampleBank:					; CODE XREF: ROM:018Fj
						; ROM:019Ej
		ld	hl,  Input+1
		call	LoadBank		; (hl) = Bank offset (Big Endian)
		ld	hl,  Input+2
		ld	a, (hl)			; load offset high byte
		or	80h			; ensure offset	is 8000h-based
		inc	hl
		ld	l, (hl)			; load offset low byte
		ld	h, a			; hl = 68kSampleTable
		ld	a, (SampleID)
		ld	e, a
		ld	d, 0			; de = Sample
		sla	e
		rl	d
		sla	e
		rl	d
		sla	e
		rl	d			; de = Sample*8
		add	hl, de			; hl = 68kSampleTable +	Sample*8
		ld	de, PCM_Data
		ld	b, (hl)
		ld	a, (Input+2)		; load offset high byte
		or	80h			; ensure offset	is 8000h-based
		add	a, b			; add (hl++) to	offset's high byte
		ld	b, a
		inc	hl
		ld	c, (hl)			; load offset's low byte
		ld	a, (Input+3)
		add	a, c			; add (hl++) to	offset's low byte
		ld	c, a
		jr	nc, loc_1DE		; if no	carry occured, branch
		inc	b			; otherwise, increase resulting	offset's high byte

loc_1DE:					; CODE XREF: ROM:01DBj
		inc	hl
		push	bc			; bc = 68kSampleTable +	(hl++) -- Sample offset
		ldi				; transfer 4 bytes from	(hl++) to (de++)
		ldi				; ''

loc_1E4:					; ''
		ldi
		ldi				; ''
		pop	bc
		ex	de, hl			; hl = PCM_Data
		ld	(hl), b
		inc	hl
		ld	(hl), c			; load PCM offset
		ld	hl, PCM_Data
		call	PlayPCM			; hl = PCM Data	offset
		call	DoBankSwitch
		call	RestoreFM6
		ei
		ret

; =============== S U B	R O U T	I N E =======================================

; hl = PCM Data	offset

PlayPCM:					; CODE XREF: ROM:0166p
						; ROM:017Bp ...
		ld	b, (hl)
		inc	hl
		ld	c, (hl)			; bc = PCM length
		inc	hl
		ld	d, (hl)			; h = ???
		inc	hl
		ld	e, (hl)			; l = Pitch
		inc	hl
		ld	a, (hl)
		inc	hl
		ld	l, (hl)			; de = PCM offset
		ld	h, a
		ex	de, hl
		ld	a, 80h
		ld	(DAC_Playing), a	; setup	DAC playing flag
		ld	h, 2Bh
		call	Write_YM_Port0		; YM ->	Enable DAC
		xor	a
		ld	(Command), a

DAC_PlaybackLoop:				; CODE XREF: PlayPCM+37j
		ld	a, (Command)		; load command
		or	a			; test it
		call	nz, sub_23E		; if not zero, branch
		push	bc
		ld	b, l			; b = Pitch

PitchDAC:					; CODE XREF: PlayPCM:PitchDACj
		djnz	$			; do pitching
		pop	bc
		ld	a, 2Ah
		ld	(YM_Port0_Reg),	a	; YM ->	Prepare	to output DAC
		ld	a, (de)
		nop
		nop
		nop
		ld	(YM_Port0_Val),	a	; YM ->	Send to	DAC
		inc	de			; next PCM byte
		dec	bc			; decrease length
		ld	a, b
		or	c			; is length counter zero?
		jp	nz, DAC_PlaybackLoop	; if not, loop

StopDACPlayback:				; CODE XREF: sub_23E+14j
		xor	a
		ld	(DAC_Playing), a	; clear	DAC playing flag
		ld	h, 2Bh
		jp	Write_YM_Port0		; YM ->	Disable	DAC
; End of function PlayPCM


; =============== S U B	R O U T	I N E =======================================


sub_23E:					; CODE XREF: PlayPCM+1Fp
		cp	0Ch			; is command 0Ch?
		jr	nz, loc_24A		; if not, branch
		call	WaitUnpauseCommand
		xor	a
		ld	(Command), a		; clear	command
		ret
; ---------------------------------------------------------------------------

loc_24A:					; CODE XREF: sub_23E+2j
		cp	6			; is command 6?
		ret	nz			; if not, return
		pop	hl
		xor	a
		ld	(Command), a		; clear	command
		jr	StopDACPlayback		; stop DAC playback and	return
; End of function sub_23E


; =============== S U B	R O U T	I N E =======================================


RestoreFM6:					; CODE XREF: ROM:0169p
						; ROM:0181p ...
		call	RestoreFM6_Pan_AMS_FMS
		ld	bc, WriteFMData		; h = Register,	a = Value
		ld	(loc_470+1), bc		; this offset is dynamic!
		ld	bc, WritePSGData	; a = Data
		ld	(loc_42A+1), bc		; this offset is dynamic!
		ld	(loc_45E+1), bc		; this offset is dynamic!
		ld	(loc_464+1), bc		; this offset is dynamic!
		ret
; End of function RestoreFM6


; =============== S U B	R O U T	I N E =======================================


DisableFM6:					; CODE XREF: ROM:0160p
						; ROM:016Fp ...

; FUNCTION CHUNK AT 029A SIZE 00000014 BYTES

		ld	bc, WriteFMData_NoTest	; Perhaps lack of testing means	SFX or when SFX	isn't playing
		ld	(loc_470+1), bc		; this offset is dynamic!
		ld	bc, WritePSGData_NoTest	; Perhaps lack of testing means	SFX or when SFX	isn't playing
		ld	(loc_42A+1), bc		; this offset is dynamic!
		ld	(loc_45E+1), bc		; this offset is dynamic!
		ld	(loc_464+1), bc		; this offset is dynamic!
		jp	loc_29A
; End of function DisableFM6


; =============== S U B	R O U T	I N E =======================================


SendChannelKeyEvent:				; CODE XREF: sub_2D4+14p
						; sub_2D4+2Bp
		ld	a, (CurrentChannel)
		cp	6			; is this channel 6 and	higher (PSG)?
		ret	nc			; if yes, return
		sub	3			; subtract 3 from channel number
		ccf				; FM1-FM3 -> Carry=0, FM4-FM6 -> Carry=1
		ld	c, a
		ld	a, (u_KeyEventForYM)
		adc	a, c			; FM1-FM3 -> 0..2, FM4-FM6 -> 4..6 (Warning! The code below, however works for FM1-FM3 only, unless docs are wrong)
		ld	h, 28h
		jp	Write_YM_Port0		; YM ->	Set key	event for this channel
; End of function SendChannelKeyEvent

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DisableFM6

loc_29A:					; CODE XREF: DisableFM6+16j
		push	hl
		push	bc
		push	de
		xor	a
		ld	c, 3			; force	'key off' event, channels > FM3?
		call	sub_306			; something to do about	SFX/BGM	simulateous processing
		ld	a, 0C0h
		ld	h, 0B6h
		call	Write_YM_Port1		; YM ->	Set FM6	pan to LR
		pop	de
		pop	bc
		pop	hl
		ret
; END OF FUNCTION CHUNK	FOR DisableFM6

; =============== S U B	R O U T	I N E =======================================


RestoreFM6_Pan_AMS_FMS:				; CODE XREF: RestoreFM6p
		ld	a, 0FFh
		ld	c, 0F3h
		call	sub_306			; something to do about	SFX/BGM	simulateous processing
		ld	ix, FM6_SFX_Struct	; load SFX struct
		ld	a, (SFX_ChannelsPlaying)
		and	20h			; is SFX playing in FM6?
		jr	nz, loc_2C4		; if yes, branch
		ld	ix, FM6_BGM_Struct	; load BMG struct instead

loc_2C4:					; CODE XREF: RestoreFM6_Pan_AMS_FMS+10j
		ld	a, (ix+2Bh)		; load AMF/FMS enable flag
		or	a			; test it
		ld	a, (ix+2Ch)		; load pan/AMS/FMS setting
		jr	nz, loc_2CF		; if AMS/FMS flag is on, branch
		and	0C0h			; otherwise, clear AMS/FMS settings

loc_2CF:					; CODE XREF: RestoreFM6_Pan_AMS_FMS+1Dj
		ld	h, 0B6h
		jp	Write_YM_Port1		; YM ->	Set FM6	panning
; End of function RestoreFM6_Pan_AMS_FMS


; =============== S U B	R O U T	I N E =======================================

; something to do with sending keys
; a = PSG Flag setting,	hl = Channel struct offset

sub_2D4:					; CODE XREF: sub_3A0+3p
						; sub_3A8+1j
		push	bc
		push	de
		push	hl
		push	hl
		pop	ix
		ld	(SFX_Playing), a
		ld	a, (byte_198D)
		or	a
		jp	nz, loc_2F2
		bit	7, (ix+1Eh)
		call	nz, SendChannelKeyEvent
		xor	a			; mute channel
		call	SetChannelVolume
		jp	loc_302
; ---------------------------------------------------------------------------

loc_2F2:					; CODE XREF: sub_2D4+Dj
		bit	7, (ix+1Eh)
		jp	z, loc_302
		ld	a, (ix+2Ah)		; a = Volume
		call	SetChannelVolume
		call	SendChannelKeyEvent

loc_302:					; CODE XREF: sub_2D4+1Bj
						; sub_2D4+22j
		pop	hl
		pop	de
		pop	bc
		ret
; End of function sub_2D4


; =============== S U B	R O U T	I N E =======================================

; something to do about	SFX/BGM	simulateous processing

sub_306:					; CODE XREF: ROM:0127p
						; ROM:0135p ...
		ld	(byte_198D), a
		ld	a, c
		ld	(u_KeyEventForYM), a
		ld	hl, FM1_BGM_Struct
		ld	de, FM1_SFX_Struct
		ld	a, (BGM_ChannelsPlaying)
		ld	c, a
		ld	a, (SFX_ChannelsPlaying)
		ld	b, a
		xor	a

loc_31C:					; CODE XREF: sub_306+37j
		push	af
		ld	(CurrentChannel), a
		srl	b			; test SFX channel bit
		jr	nc, loc_329		; if the channel's not playing set, branch
		call	sub_3A0
		jr	loc_330
; ---------------------------------------------------------------------------

loc_329:					; CODE XREF: sub_306+1Cj
		srl	c			; test BGM channel bit
		jr	nc, loc_330		; if the channel's not playing, branch
		call	sub_3A8

loc_330:					; CODE XREF: sub_306+21j
						; sub_306+25j
		push	bc
		ld	bc, 54h			; bc = Channel size
		add	hl, bc			; switch to next channel for BGM
		ex	de, hl
		add	hl, bc			; switch to next channel for SFX
		ex	de, hl
		pop	bc
		pop	af
		inc	a
		cp	6			; is channel FM6 and lower?
		jr	c, loc_31C		; if yes, branch

loc_33F:					; CODE XREF: sub_306+76j
		push	af
		ld	(CurrentChannel), a
		srl	b			; test SFX channel bit
		jr	nc, loc_34C		; if not set, branch
		call	sub_3A0
		jr	loc_36F
; ---------------------------------------------------------------------------

loc_34C:					; CODE XREF: sub_306+3Fj
		srl	c			; test BGM channel bit
		jr	nc, loc_355		; if not set, branch
		call	sub_3A8
		jr	loc_36F
; ---------------------------------------------------------------------------

loc_355:					; CODE XREF: sub_306+48j
		push	de
		pop	ix			; ix = SFX struct
		ld	a, (ix+3Ch)
		or	a
		jr	z, loc_363
		call	sub_3A0
		jr	loc_36F
; ---------------------------------------------------------------------------

loc_363:					; CODE XREF: sub_306+56j
		push	hl
		pop	ix			; ix = BGM struct
		ld	a, (ix+3Ch)
		or	a
		jr	z, loc_36F
		call	sub_3A8

loc_36F:					; CODE XREF: sub_306+44j
						; sub_306+4Dj ...
		push	bc
		ld	bc, 54h			; bc = Channel size
		add	hl, bc			; switch to next channel for BGM
		ex	de, hl
		add	hl, bc			; switch to next channel for SFX
		ex	de, hl
		pop	bc
		pop	af
		inc	a
		cp	8			; is channel below 8?
		jr	c, loc_33F		; if yes, branch
		ld	(CurrentChannel), a
		ld	a, (SFX_ChannelsPlaying+1)
		or	a
		jr	nz, sub_3A0
		ld	a, (BGM_ChannelsPlaying+1)
		or	a
		jr	nz, sub_3A8
		push	de
		pop	ix
		ld	a, (ix+3Ch)
		or	a
		jr	nz, sub_3A0
		push	hl
		pop	ix
		ld	a, (ix+3Ch)
		or	a
		jr	nz, sub_3A8
		ret
; End of function sub_306


; =============== S U B	R O U T	I N E =======================================


sub_3A0:					; CODE XREF: sub_306+1Ep
						; sub_306+41p ...
		ex	de, hl			; load SFX channel pointer
		ld	a, 0FFh
		call	sub_2D4			; something to do with sending keys
						; a = PSG Flag setting,	hl = Channel struct offset
		ex	de, hl
		ret
; End of function sub_3A0


; =============== S U B	R O U T	I N E =======================================


sub_3A8:					; CODE XREF: sub_306+27p
						; sub_306+4Ap ...
		xor	a
		jp	sub_2D4			; something to do with sending keys
; End of function sub_3A8			; a = PSG Flag setting,	hl = Channel struct offset


; =============== S U B	R O U T	I N E =======================================


SetChannelVolume:				; CODE XREF: sub_2D4+18p
						; sub_2D4+28p ...
		or	a
		jp	nz, loc_3B5
		ld	b, 7Fh			; mute volume
		jp	loc_3CD
; ---------------------------------------------------------------------------

loc_3B5:					; CODE XREF: SetChannelVolume+1j
		sub	63h
		neg
		ld	b, (ix+29h)		; b = Volume modifier
		call	CalcFMVolume
		ld	b, a
		ld	a, (SFX_Playing)
		or	a
		jr	nz, loc_3CD
		ld	a, (FadeOutVolume)
		call	CalcFMVolume
		ld	b, a

loc_3CD:					; CODE XREF: SetChannelVolume+6j
						; SetChannelVolume+18j
		ld	a, (CurrentChannel)
		cp	6			; is this channel 6 and	above (PSG)?
		jp	nc, u_VolumeControl_PSG	; if yes, branch
		ld	l, (ix+1Dh)
		call	GetFMInstrPointer
		ld	de, 6
		add	hl, de
		ex	de, hl			; de = hl + 6 (FM volumes table)
		ld	c, (ix+1Eh)
		ld	a, (CurrentChannel)	; load current channel number
		ld	h, 3
		sub	h			; subtract 3 from it
		ccf
		adc	a, h			; add 3	if FM1-FM3, add	4 if FM4-FM6
		and	h			; FM1-FM3 -> 0..2, FM4-FM6 -> 0..2
		add	a, 3Dh			; 3Dh +	3h = 40h (YM volume registers)
		call	SetFMVolume
		ld	a, 8			; 40h +	8h = 48h
		call	SetFMVolume
		ld	a, 0FCh			; 48h -	4h = 44h
		call	SetFMVolume
		ld	a, 8			; 44h +	8h = 4Ch
		jp	SetFMVolume
; ---------------------------------------------------------------------------

u_VolumeControl_PSG:				; CODE XREF: SetChannelVolume+26j
		sub	6
		cp	2
		jp	z, loc_42D
		add	a, a			; a = a*2
		add	a, 9			; a = a*2+9
		add	a, a			; a = (a*2+9)*2
		add	a, a
		add	a, a			; a = (a*2+9)*8
		add	a, a
		ld	l, a			; l = a*32 + 144
		ld	a, (ix+1Ch)
		or	a
		jr	z, loc_417
		ld	l, 0F0h

loc_417:					; CODE XREF: SetChannelVolume+67j
						; SetChannelVolume+87j	...
		srl	b
		srl	b
		ld	a, b
		cp	10h
		jr	c, loc_422
		ld	a, 0Fh

loc_422:					; CODE XREF: SetChannelVolume+72j
		cp	(ix+42h)
		ret	z
		ld	(ix+42h), a
		or	l

loc_42A:					; DATA XREF: ROM:0118w
						; ROM:0142w ...
		jp	WritePSGData		; this offset is dynamic!
; ---------------------------------------------------------------------------

loc_42D:					; CODE XREF: SetChannelVolume+58j
		ld	a, (ix+1Ch)
		or	a
		ld	l, 0D0h
		jp	z, loc_417
		ld	l, 0F0h
		ld	a, (SFX_Playing)
		or	a
		ld	a, (byte_16)
		jr	z, loc_444
		ld	a, (byte_1F7C)

loc_444:					; CODE XREF: SetChannelVolume+93j
		bit	3, a
		jp	z, loc_417
		srl	b
		srl	b
		ld	a, b
		cp	10h
		jr	c, loc_454
		ld	a, 0Fh

loc_454:					; CODE XREF: SetChannelVolume+A4j
		cp	(ix+42h)
		ret	z
		ld	(ix+42h), a
		push	af
		or	0D0h

loc_45E:					; DATA XREF: ROM:011Cw
						; ROM:0146w ...
		call	WritePSGData		; this offset is dynamic!
		pop	af
		or	0F0h

loc_464:					; DATA XREF: ROM:0120w
						; ROM:014Aw ...
		jp	WritePSGData		; this offset is dynamic!
; End of function SetChannelVolume


; =============== S U B	R O U T	I N E =======================================


SetFMVolume:					; CODE XREF: SetChannelVolume+42p
						; SetChannelVolume+47p	...
		add	a, h
		ld	h, a			; h += a
		ld	a, (de)			; load YM register value
		inc	de
		srl	c			; (?) perhaps dynamic volume bit
		call	c, CalcFMVolume

loc_470:					; DATA XREF: ROM:0111w
						; ROM:013Bw ...
		jp	WriteFMData		; this offset is dynamic!
; End of function SetFMVolume


; =============== S U B	R O U T	I N E =======================================


CalcFMVolume:					; CODE XREF: SetChannelVolume+10p
						; SetChannelVolume+1Dp	...
		add	a, b			; increase volume level	(TL)
		jp	pe, VolumeOverflow	; if overflow, branch
		ret	p			; return if 7Fh	and below

VolumeOverflow:					; CODE XREF: CalcFMVolume+1j
		ld	a, 7Fh			; reset	volume to 7Fh
		ret
; End of function CalcFMVolume


; =============== S U B	R O U T	I N E =======================================


InitPSG:					; CODE XREF: ROM:00C1p
		ld	hl, PSG_Setup

InitPSG_Loop:					; CODE XREF: InitPSG+Aj
		ld	a, (hl)
		inc	hl
		ld	(PSG_Port), a
		cp	0FFh
		jr	nz, InitPSG_Loop
		ret
; End of function InitPSG

; ---------------------------------------------------------------------------
PSG_Setup:	db 80h,	0, 0A0h, 0, 0C0h, 0, 0E0h, 9Fh,	0BFh, 0DFh, 0FFh
						; DATA XREF: InitPSGo

; =============== S U B	R O U T	I N E =======================================


ResetCommand:					; CODE XREF: SwapEndianess+9j
						; ROM:0D09j ...
		xor	a
		ld	(Command), a
		ret
; End of function ResetCommand


; =============== S U B	R O U T	I N E =======================================

; de = Destination offset

SwapEndianess:					; CODE XREF: ROM:04ADj
						; ROM:04B8j
		ld	hl, Input
		ld	a, (hl)
		ld	(de), a
		inc	hl
		dec	de
		ld	a, (hl)
		ld	(de), a
		jp	ResetCommand
; End of function SwapEndianess

; ---------------------------------------------------------------------------

u_FetchOffset:					; DATA XREF: ROM:CommandsTableo
		ld	a, (Input+2)
		ld	(u_OffsetByte),	a
		ld	de,  Offset_BGM+1
		jr	SwapEndianess		; de = Destination offset
; ---------------------------------------------------------------------------

u_FetchOffset2:					; DATA XREF: ROM:CommandsTableo
		ld	a, (Input+2)
		ld	(u_OffsetByte2), a
		ld	de,  Offset_SFX+1
		jr	SwapEndianess		; de = Destination offset

; =============== S U B	R O U T	I N E =======================================


Write_FM_I:					; CODE XREF: StopTrack+4Dj
						; u_FM_PlayNote+50j ...
		call	TestChannelOn
		ret	c
; End of function Write_FM_I


; =============== S U B	R O U T	I N E =======================================

; h = Register,	a = Value

Write_YM_Port0:					; CODE XREF: ROM:008Ep
						; ROM:0094p ...
		push	af

loc_4BF:					; CODE XREF: Write_YM_Port0+5j
		ld	a, (YM_Port0_Reg)	; load YM state
		or	a			; test it
		jp	m, loc_4BF		; if YM's busy, loop
		ld	a, 0FFh
		ld	(BusyFlag), a
		ld	a, h
		ld	(YM_Port0_Reg),	a
		pop	af
		nop
		nop
		ld	(YM_Port0_Val),	a
		xor	a
		ld	(BusyFlag), a
		ret
; End of function Write_YM_Port0

; ---------------------------------------------------------------------------

Write_FM_II:
		call	TestChannelOn
		ret	c

; =============== S U B	R O U T	I N E =======================================

; h = Register,	a = Value

Write_YM_Port1:					; CODE XREF: DisableFM6+39p
						; RestoreFM6_Pan_AMS_FMS+23j ...
		push	af

loc_4DF:					; CODE XREF: Write_YM_Port1+5j
		ld	a, (YM_Port0_Reg)
		or	a
		jp	m, loc_4DF
		ld	a, 0FFh
		ld	(BusyFlag), a
		ld	a, h
		ld	(YM_Port1_Reg),	a
		pop	af
		nop
		nop
		ld	(YM_Port1_Val),	a
		xor	a
		ld	(BusyFlag), a
		ret
; End of function Write_YM_Port1


; =============== S U B	R O U T	I N E =======================================

; h = Register,	a = Value

WriteFMData:					; CODE XREF: SetFMVolume:loc_470j
						; SetFM_FB_and_Algorithm+Ej ...
		call	TestChannelOn
		ret	c			; if channel's off, return

WriteFMData_NoTest:				; DATA XREF: ROM:010Eo
						; DisableFM6o
		push	af			; Perhaps lack of testing means	SFX or when SFX	isn't playing
		ld	a, (CurrentChannel)
		cp	3			; is this channel FM3 and above?
		jr	nc, loc_509		; if yes, branch
		pop	af
		jr	Write_YM_Port0		; h = Register,	a = Value
; ---------------------------------------------------------------------------

loc_509:					; CODE XREF: WriteFMData+Aj
		pop	af
		jr	Write_YM_Port1		; h = Register,	a = Value
; End of function WriteFMData

; ---------------------------------------------------------------------------
		db 0C9h	; É

; =============== S U B	R O U T	I N E =======================================

; a = Data

WritePSGData:					; CODE XREF: SetChannelVolume:loc_42Aj
						; SetChannelVolume:loc_45Ep ...
		call	TestChannelOn
		ret	c			; if channel's off, return

WritePSGData_NoTest:				; DATA XREF: ROM:0115o
						; DisableFM6+7o
		ld	(PSG_Port), a		; Perhaps lack of testing means	SFX or when SFX	isn't playing
		ret
; End of function WritePSGData


; =============== S U B	R O U T	I N E =======================================

; a = Data, h =	Data2

WritePSGData2:					; CODE XREF: sub_95D+A5p
		call	TestChannelOn
		ret	c			; if channel's off, branch
		ld	(PSG_Port), a
		ld	a, h
		ld	(PSG_Port), a
		ret
; End of function WritePSGData2


; =============== S U B	R O U T	I N E =======================================


TestChannelOn:					; CODE XREF: Write_FM_Ip
						; ROM:Write_FM_IIp ...
		push	af
		ld	a, (ix+0)
		cp	0FFh
		jr	nz, ChannelOn
		pop	af
		scf				; set Carry flag
		ret
; ---------------------------------------------------------------------------

ChannelOn:					; CODE XREF: TestChannelOn+6j
		pop	af
		or	a			; clear	Carry flag
		ret
; End of function TestChannelOn


; =============== S U B	R O U T	I N E =======================================


SetTimerB:					; CODE XREF: ROM:0087p
						; InitBGMPlayback+1Cp ...
		push	af
		push	hl
		push	de
		ld	hl, 2084h
		add	a, 32h			; a = 6Eh+32h =	0A0h
		ld	e, a			; e = a+32h
		ld	a, 0			; a = x
		adc	a, 0			; a = x+Carry
		ld	d, a			; d = x+Carry
		xor	a			; a = 0

SetTimerB_Loop:					; CODE XREF: SetTimerB+15j
		sbc	hl, de			; de = 00A0h
		jp	c, loc_547
		inc	a
		jp	SetTimerB_Loop
; ---------------------------------------------------------------------------

loc_547:					; CODE XREF: SetTimerB+11j
		ld	h, 26h
		neg
		call	Write_YM_Port0		; YM ->	Set Timer B value
		pop	de
		pop	hl
		pop	af
		ret
; End of function SetTimerB


; =============== S U B	R O U T	I N E =======================================

; Input:
; l = Instrument number
;
; Output:
; hl = Instrument offset

GetFMInstrPointer:				; CODE XREF: SetChannelVolume+2Cp
						; sub_6A3+14p ...
		ld	h, 0
		add	hl, hl
		add	hl, hl			; hl = Instr*4
		ld	d, h
		ld	e, l			; de = hl
		add	hl, hl			; hl = Instr*8
		add	hl, hl			; hl = Instr*16
		add	hl, hl			; hl = Instr*32
		add	hl, de			; hl = Instr*36
		push	hl
		ld	a, (SFX_Playing)
		or	a
		jr	nz, loc_56C
		ld	hl, 0Ah
		ld	de, (Offset_BGM)	; de = BGM offset
		jr	CalcInstrOffset
; ---------------------------------------------------------------------------

loc_56C:					; CODE XREF: GetFMInstrPointer+Fj
		ld	hl, 2
		ld	de, (Offset_SFX)

CalcInstrOffset:				; CODE XREF: GetFMInstrPointer+18j
		add	hl, de			; hl = (Offset)+0Ah
		ld	a, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, a			; hl = FM Instruments offset
		add	hl, de
		pop	de			; de = Instr*40
		add	hl, de			; hl = this instrument's pointer
		ret
; End of function GetFMInstrPointer


; =============== S U B	R O U T	I N E =======================================

; something to do with 'key off'?

StopTrack:					; CODE XREF: sub_6A3+Cp
						; LoadInstrumentp ...
		bit	7, (ix+2Bh)
		jr	z, loc_5B7
		push	de
		ld	a, (ix+23h)
		and	7Fh
		sub	64h
		neg
		ld	h, 0
		ld	l, a			; hl = a
		sla	l
		rl	h
		sla	l
		rl	h			; hl = hl<<2
		ld	de, 5FFCh
		bit	6, (ix+2Bh)
		jr	z, loc_5AA
		ld	a, l
		cpl
		ld	l, a
		ld	a, h
		cpl
		ld	h, a
		inc	hl
		ld	de, 0

loc_5AA:					; CODE XREF: StopTrack+22j
		ld	(ix+0Dh), l
		ld	(ix+0Eh), h
		ld	(ix+0Bh), e
		ld	(ix+0Ch), d
		pop	de

loc_5B7:					; CODE XREF: StopTrack+4j
		res	7, (ix+1Eh)
		ld	a, (CurrentChannel)
		cp	6			; is this channel 6 and	above (PSG)?
		jr	nc, loc_5CC		; if yes, branch
		sub	3			; subtract 3 from channel number
		ccf				; FM1-FM3 -> Carry=0, FM4-FM6 -> Carry=1
		adc	a, 3			; FM1-FM3 -> 0..2, FM4-FM6 -> 4..6
		ld	h, 28h			; YM key events	register
		jp	Write_FM_I		; YM ->	Raise 'key off' event for this channel
; ---------------------------------------------------------------------------

loc_5CC:					; CODE XREF: StopTrack+44j
		ld	a, (ix+3Ch)
		and	44h
		ret	nz
		ld	(ix+3Ch), 40h
		ret
; End of function StopTrack


; =============== S U B	R O U T	I N E =======================================


u_FM_PlayNote:					; CODE XREF: u_PlayNote+62p
		ld	a, (CurrentChannel)
		ld	c, a
		ld	a, (u_ChanNum)
		cp	c
		jr	nz, loc_617
		ld	a, (byte_1C)
		rla
		jr	nc, loc_5F3
		ld	hl, u_LFO_Byte
		ld	a, (hl)
		or	0C0h
		ld	(hl), a
		inc	hl
		ld	a, (hl)
		or	0C0h
		ld	(hl), a

loc_5F3:					; CODE XREF: u_FM_PlayNote+Ej
		ld	a, (ix+31h)
		ld	(byte_1D), a
		ld	hl, (word_2B)
		or	a
		jr	z, loc_609
		ld	a, (byte_1C)
		neg
		and	7Fh
		ld	hl, 0

loc_609:					; CODE XREF: u_FM_PlayNote+26j
		ld	(byte_2D), a
		ld	a, 1
		ld	(byte_32), a
		ld	(word_29), hl
		ld	(word_2E), hl

loc_617:					; CODE XREF: u_FM_PlayNote+8j
		set	7, (ix+1Eh)		; (?) disable volume effects
		ld	a, c
		cp	6			; is this channel 6 and	above (PSG)?
		jr	nc, loc_62A		; if yes, branch
		sub	3			; FM1-FM3 -> -3..-1, FM4-FM6 ->	0..2
		ccf				; FM1-FM3 -> Carry=0, FM4-FM6 -> Carry=1
		adc	a, 0F3h			; FM1-FM3 -> 0F0h..0F2h, FM4-FM6 -> 0F4h..0F6h
		ld	h, 28h			; YM key events	register
		jp	Write_FM_I		; YM ->	Force 'key on' event for the current channel
; ---------------------------------------------------------------------------

loc_62A:					; CODE XREF: u_FM_PlayNote+47j
		ld	(ix+3Ch), 80h
		ret
; End of function u_FM_PlayNote


; =============== S U B	R O U T	I N E =======================================


SetFM_FB_and_Algorithm:				; CODE XREF: sub_6A3+2Cp
						; LoadInstrument+28p
		ld	a, (CurrentChannel)
		sub	3			; FM1-FM3 -> -3..-1, FM4-FM6 ->	0..2
		ccf				; FM1-FM3 -> Carry=0, FM4-FM6 -> Carry=1
		adc	a, 0B3h			; FM1-FM3 -> 0B0h..0B2h, FM4-FM6 -> 0B4h..0B6h
		and	0FBh			; FM1-FM3 -> 0B0h..0B2h, FM4-FM6 -> 0B0h..0B2h
		ld	h, a			; h = YM pan, AMS/FMS register
		ld	a, (ix+21h)		; a = Feedback/Algorithm
		jp	WriteFMData		; YM ->	Set feedback and algorithm
; End of function SetFM_FB_and_Algorithm


; =============== S U B	R O U T	I N E =======================================


SetFM_Pan_AMS_FMS:				; CODE XREF: sub_6A3+49p
						; LoadInstrument+45p ...
		ld	a, (CurrentChannel)
		cp	5			; is this channel below	5 (FM1-FM5)?
		jr	c, loc_64F		; if yes, branch
		ret	nz			; if not FM5, return
		ld	h, a
		ld	a, (byte_C)
		or	a
		ret	nz
		ld	a, h

loc_64F:					; CODE XREF: SetFM_Pan_AMS_FMS+5j
		ld	h, 3
		sub	h
		ccf
		adc	a, h
		and	h
		add	a, 0B4h
		ld	h, a			; h = YM panning, AMS/FMS register
		ld	a, (ix+2Bh)		; load AMS/FMS byte
		and	1			; test bit 0
		ld	a, (ix+2Ch)		; load panning,	AMF/FMS	setting
		jp	nz, WriteFMData		; if AMS/FMS flag is set, branch
		and	0C0h			; otherwise, clear AMS/FMS bits
		jp	WriteFMData		; apply	panning	only
; End of function SetFM_Pan_AMS_FMS

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LoadInstrument

loc_668:					; CODE XREF: sub_6A3+8Ej
						; LoadInstrument+8Aj ...
		ld	a, (ix+2Dh)
		or	40h
		ld	(u_LFO_Byte), a
		ld	a, (ix+30h)
		ld	(byte_1C), a
		ld	a, (ix+2Eh)
		ld	(word_2B), a
		ld	a, (ix+2Fh)
		ld	(word_2B+1), a
		ret
; END OF FUNCTION CHUNK	FOR LoadInstrument
; ---------------------------------------------------------------------------
; Unknown PSG-related code
; START	OF FUNCTION CHUNK FOR FlagE2_u_PSGEffect

loc_683:					; CODE XREF: FlagE2_u_PSGEffect+3j
		ld	c, a
		ld	a, (CurrentChannel)
		cp	6			; is this channel below	6 (FM)?
		ret	c			; if yes, return
		ld	a, (SFX_Playing)
		or	a
		ld	a, c
		jr	nz, loc_699
		or	80h
		ld	(byte_16), a
		jp	loc_69C
; ---------------------------------------------------------------------------

loc_699:					; CODE XREF: FlagE2_u_PSGEffect-D1Bj
		ld	(byte_1F7C), a

loc_69C:					; CODE XREF: FlagE2_u_PSGEffect-D14j
		and	7
		or	0E0h
		jp	WritePSGData		; a = Data
; END OF FUNCTION CHUNK	FOR FlagE2_u_PSGEffect

; =============== S U B	R O U T	I N E =======================================


sub_6A3:					; CODE XREF: InitChannel+2Dp
		ld	a, (CurrentChannel)
		cp	6			; is this channel 6 and	above (PSG)?
		jp	nc, loc_735		; if yes, branch
		ld	(ix+1Eh), 0Fh		; (?) set volume control bits
		call	StopTrack		; something to do with 'key off'?
		xor	a
		call	u_UpdateFMVolume
		ld	l, c
		call	GetFMInstrPointer
		ex	de, hl
		ld	a, (de)
		inc	de
		and	3Fh
		ld	(ix+21h), a
		and	7
		ld	hl, byte_7A5
		ld	c, a
		ld	b, 0			; bc = a
		add	hl, bc
		ld	a, (hl)
		ld	(ix+1Eh), a
		call	SetFM_FB_and_Algorithm
		ld	a, (de)
		inc	de
		ld	l, a
		and	70h
		rrca
		rrca
		rrca
		rrca
		ld	(ix+2Eh), a
		ld	a, l
		and	3
		ld	(ix+2Fh), a
		ld	a, (ix+2Ch)
		and	0C0h
		ld	(ix+2Ch), a
		call	SetFM_Pan_AMS_FMS
		ld	a, (CurrentChannel)
		ld	h, 3
		sub	h
		ccf
		adc	a, h
		and	h
		add	a, 2Ch
		ld	h, a
		call	sub_78D
		ld	a, h

loc_6FF:
		add	a, 10h
		ld	h, a
		inc	de
		inc	de
		inc	de
		inc	de
		ld	b, 4

loc_708:					; CODE XREF: sub_6A3+68j
		call	sub_78D
		djnz	loc_708
		inc	de
		inc	de
		inc	de
		inc	de
		inc	de

loc_712:					; CODE XREF: sub_6A3+E7j
		ld	a, (de)
		inc	de
		and	7
		ld	(ix+2Dh), a
		inc	de
		inc	de
		inc	de
		ld	a, (de)
		ld	(ix+30h), a
		ld	a, (CurrentChannel)
		ld	c, a
		cp	6
		ret	nc
		ld	a, (u_ChanNum)
		cp	c
		ret	nz
		ld	a, (ix+2Bh)
		and	1
		jp	nz, loc_668
		ret
; ---------------------------------------------------------------------------

loc_735:					; CODE XREF: sub_6A3+5j
		xor	a
		call	u_UpdateFMVolume
		ld	l, c
		ld	h, 0
		add	hl, hl
		add	hl, hl
		add	hl, hl
		add	hl, hl
		push	hl
		ld	a, (SFX_Playing)
		or	a
		jr	nz, loc_750
		ld	hl, 0Ch
		ld	de, (Offset_BGM)
		jr	loc_757
; ---------------------------------------------------------------------------

loc_750:					; CODE XREF: sub_6A3+A2j
		ld	hl, 4
		ld	de, (Offset_SFX)

loc_757:					; CODE XREF: sub_6A3+ABj
		add	hl, de
		ld	a, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, a
		add	hl, de
		pop	de
		add	hl, de
		push	hl
		push	ix
		pop	hl
		ld	de, 35h	; '5'
		add	hl, de
		ex	de, hl
		pop	hl
		ldi
		ldi
		ldi
		ldi
		ldi
		ldi
		ldi
		ld	a, (hl)
		ld	e, a
		and	70h ; 'p'
		rrca
		rrca
		rrca
		rrca
		ld	(ix+2Eh), a
		ld	a, e
		and	3
		ld	(ix+2Fh), a
		inc	hl
		ex	de, hl
		jp	loc_712
; End of function sub_6A3


; =============== S U B	R O U T	I N E =======================================


sub_78D:					; CODE XREF: sub_6A3+58p
						; sub_6A3:loc_708p
		ld	a, 4
		call	sub_79E
		ld	a, 8
		call	sub_79E
		ld	a, 0FCh
		call	sub_79E
		ld	a, 8
; End of function sub_78D


; =============== S U B	R O U T	I N E =======================================


sub_79E:					; CODE XREF: sub_78D+2p
						; sub_78D+7p ...
		add	a, h
		ld	h, a
		ld	a, (de)
		inc	de
		jp	WriteFMData		; h = Register,	a = Value
; End of function sub_79E

; ---------------------------------------------------------------------------
byte_7A5:	db 8, 8, 8, 8, 0Ah, 0Eh, 0Eh, 0Fh ; DATA XREF: sub_6A3+21o

; =============== S U B	R O U T	I N E =======================================

; Input:
; c = Instrument Number

LoadInstrument:					; CODE XREF: ROM:0D8Bp
						; sub_10D7+A1p	...

; FUNCTION CHUNK AT 0668 SIZE 0000001B BYTES

		call	StopTrack		; something to do with 'key off'?
		ld	a, (CurrentChannel)	; load current channel
		cp	6			; is this channel 6 and	above (PSG)?
		jp	nc, LoadInstr_PSG	; if yes, branch
		ld	l, c
		call	GetFMInstrPointer
		ex	de, hl			; de = Instrument pointer
		ld	a, (de)			; load feedback/algorithm from instrument
		inc	de			; next instrument byte
		and	3Fh
		ld	(ix+21h), a		; set feedback/algorithm for channel
		and	7			; mask algorithm only
		ld	hl, u_OperatorsVolCtrlData
		ld	c, a
		ld	b, 0			; bc = Algorithm
		add	hl, bc
		ld	a, (hl)
		ld	(ix+1Eh), a		; set volume control bits based	on instrument algorithm
		xor	a
		call	sub_8AF
		call	SetFM_FB_and_Algorithm
		ld	a, (de)
		inc	de
		ld	l, a
		and	70h
		rrca
		rrca
		rrca
		rrca
		ld	(ix+2Eh), a
		ld	a, l
		and	3
		ld	(ix+2Fh), a
		ld	a, (ix+2Ch)		; load pan, AMS/FMS byte
		and	0C0h			; clear	AMS/FMS	bits
		ld	(ix+2Ch), a		; save the byte
		call	SetFM_Pan_AMS_FMS
		ld	a, (CurrentChannel)	; load current channel number
		ld	h, 3
		sub	h			; FM1-FM3 -> -2..-1, FM4-FM6 ->	0..2
		ccf				; FM1-FM3 -> Carry=0, FM4-FM6 -> Carry=1
		adc	a, h			; FM1-FM3 -> 0..2, FM4-FM6 -> 4..6
		and	h			; FM1-FM3 -> 0..2, FM4-FM6 -> 0..2
		add	a, 2Ch			; FM1-FM3 -> 2Ch..2Eh, FM4-FM6 -> 2Ch..2Eh
		ld	h, a
		call	SetFM_InstrOperators	; 30H+ - detune; multiple
		ld	a, h
		add	a, 10h
		ld	h, a			; FM1-FM3 -> 4Ch..4Eh, FM4-FM6 -> 4Ch..4Eh
		inc	de
		inc	de
		inc	de
		inc	de			; de +=	4 (Skip	TL parameters)
		ld	b, 4			; repeat 4 times

SetOperators:					; CODE XREF: LoadInstrument+64j
		call	SetFM_InstrOperators	; this cycle loads raw data in YM registers as follows:
						; 50H+ - rate scaling; attack rate
						; 60H+ - first decay rate; amplitude modulation
						; 70H+ - secondary decay rate
						; 80H+ - secondary amplitude; release rate
		djnz	SetOperators
		inc	de
		inc	de
		inc	de
		inc	de
		inc	de			; de +=	5

loc_818:					; CODE XREF: LoadInstrument+DFj
		ld	a, (de)
		inc	de
		and	7
		ld	(ix+2Dh), a
		inc	de
		inc	de
		inc	de
		ld	a, (de)
		ld	(ix+30h), a
		ld	a, (CurrentChannel)
		ld	c, a
		cp	6			; is this channel 6 and	above (PSG)?
		ret	nc			; if yes, return
		ld	a, (u_ChanNum)
		cp	c
		ret	nz
		ld	a, (ix+2Bh)
		and	1
		jp	nz, loc_668
		ret
; ---------------------------------------------------------------------------

LoadInstr_PSG:					; CODE XREF: LoadInstrument+8j
		ld	l, c
		ld	h, 0			; hl = Instr
		add	hl, hl
		add	hl, hl
		add	hl, hl
		add	hl, hl			; hl = Instr*16
		push	hl
		ld	a, (SFX_Playing)
		or	a			; is it	SFX playing?
		jr	nz, loc_852		; if yes, branch
		ld	hl, 0Ch
		ld	de, (Offset_BGM)
		jr	loc_859
; ---------------------------------------------------------------------------

loc_852:					; CODE XREF: LoadInstrument+9Aj
		ld	hl, 4
		ld	de, (Offset_SFX)

loc_859:					; CODE XREF: LoadInstrument+A3j
		add	hl, de			; hl = Offset_BGM + 0Ch
		ld	a, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, a			; hl = PSG Instruments relative	offset
		add	hl, de			; hl = PSG Instruments offset
		pop	de			; de = Instr*16
		add	hl, de			; calculate this instrument's offset
		push	hl
		push	ix
		pop	hl			; hl = Channel struct
		ld	de, 35h
		add	hl, de
		ex	de, hl			; de = (ix+25h)
		pop	hl			; hl = Instrument offset
		ldi				; copy 7 bytes from instrument to channel
		ldi				; ''
		ldi				; ''
		ldi				; ''
		ldi				; ''
		ldi				; ''
		ldi				; ''
		ld	a, (hl)
		ld	e, a
		and	70h
		rrca
		rrca
		rrca
		rrca
		ld	(ix+2Eh), a
		ld	a, e
		and	3
		ld	(ix+2Fh), a
		inc	hl
		ex	de, hl
		jp	loc_818
; End of function LoadInstrument


; =============== S U B	R O U T	I N E =======================================

; de = Instrument pointer

SetFM_InstrOperators:				; CODE XREF: LoadInstrument+54p
						; LoadInstrument:SetOperatorsp
		ld	a, 4			; FM1-FM3 -> 30h..32h, FM4-FM6 -> 30h..32h (Operator 1)
		call	u_SetFM_Operator
		ld	a, 8			; FM1-FM3 -> 38h..3Ah, FM4-FM6 -> 38h..3Ah (Operator 3)
		call	u_SetFM_Operator
		ld	a, -4			; FM1-FM3 -> 34h..36h, FM4-FM6 -> 34h..36h (Operator 2)
		call	u_SetFM_Operator
		ld	a, 8			; FM1-FM3 -> 3Ch..3Eh, FM4-FM6 -> 3Ch..3Eh (Operator 4)
; End of function SetFM_InstrOperators


; =============== S U B	R O U T	I N E =======================================


u_SetFM_Operator:				; CODE XREF: SetFM_InstrOperators+2p
						; SetFM_InstrOperators+7p ...
		add	a, h
		ld	h, a
		ld	a, (de)			; load value from instrument struct
		inc	de			; next instrument byte
		jp	WriteFMData		; h = Register,	a = Value
; End of function u_SetFM_Operator

; ---------------------------------------------------------------------------
u_OperatorsVolCtrlData:db 1000b, 1000b,	1000b, 1000b, 1010b, 1110b, 1110b, 1111b
						; DATA XREF: LoadInstrument+19o

; =============== S U B	R O U T	I N E =======================================


sub_8AF:					; CODE XREF: LoadInstrument+25p
						; ROM:0D66p ...
		ld	(ix+4Ah), a
		ld	a, (ix+2Bh)		; load AMS/FMS enable flag
		and	1			; test bit 0
		jr	z, loc_8CB		; if not set, branch
		ld	a, (word_2B+1)
		or	a
		jr	z, loc_8CB
		ld	a, (CurrentChannel)
		cp	6			; is current channel below 6 (FM)?
		jr	c, loc_8CB		; if yes, branch
		ld	a, (byte_1D)
		or	a
		ret	z

loc_8CB:					; CODE XREF: sub_8AF+8j
						; sub_8AF+Ej ...
		ld	a, (ix+4Ah)
; End of function sub_8AF


; =============== S U B	R O U T	I N E =======================================


u_UpdateFMVolume:				; CODE XREF: sub_6A3+10p
						; sub_6A3+93p ...
		push	de
		ld	(ix+2Ah), a		; update volume
		call	SetChannelVolume
		pop	de
		ret
; End of function u_UpdateFMVolume


; =============== S U B	R O U T	I N E =======================================


sub_8D7:					; CODE XREF: u_PlayNote+11p
		push	af
		push	hl
		push	de
		ld	d, a
		ld	e, 20h			; de = a<<8 + 20h
		ld	a, (ix+22h)
		or	a
		jp	p, loc_8EB

loc_8E4:					; CODE XREF: sub_8D7+Fj
		dec	d
		add	a, e
		jr	nc, loc_8E4
		sub	e
		jr	loc_8F2
; ---------------------------------------------------------------------------

loc_8EB:					; CODE XREF: sub_8D7+Aj
						; sub_8D7+18j
		sub	e
		jr	c, loc_8F1
		inc	d
		jr	loc_8EB
; ---------------------------------------------------------------------------

loc_8F1:					; CODE XREF: sub_8D7+15j
		add	a, e

loc_8F2:					; CODE XREF: sub_8D7+12j
		and	1Fh
		ld	(ix+0Bh), a
		ld	(ix+0Ch), d
		ld	a, (ix+23h)
		and	7Fh
		ld	e, a
		jr	z, loc_944
		bit	7, (ix+2Bh)
		jr	nz, loc_94D
		ld	a, (ix+20h)
		neg
		or	a
		jp	m, loc_917
		bit	7, (ix+23h)
		jr	nz, loc_944

loc_917:					; CODE XREF: sub_8D7+37j
		ld	a, e
		sub	64h
		ld	l, (ix+0Bh)
		ld	h, (ix+0Ch)		; hl = word 0Bh
		ld	e, (ix+9)
		ld	d, (ix+0Ah)		; de = word 09h
		or	a			; likely a leftover, missing condition
		sbc	hl, de			; hl < de?
		jr	c, loc_92D		; if yes, branch
		neg

loc_92D:					; CODE XREF: sub_8D7+52j
		ld	h, a
		ld	l, 0			; hl = a<<8
		sra	h
		rr	l
		sra	h
		rr	l
		sra	h
		rr	l			; hl = a<<5
		ld	(ix+0Dh), l
		ld	(ix+0Eh), h
		jr	loc_959
; ---------------------------------------------------------------------------

loc_944:					; CODE XREF: sub_8D7+29j
						; sub_8D7+3Ej
		ld	hl, 0
		ld	(ix+0Dh), l
		ld	(ix+0Eh), h

loc_94D:					; CODE XREF: sub_8D7+2Fj
		ld	l, (ix+0Bh)
		ld	h, (ix+0Ch)
		ld	(ix+9),	l		; set portamento counter (?)
		ld	(ix+0Ah), h

loc_959:					; CODE XREF: sub_8D7+6Bj
		pop	de
		pop	hl
		pop	af
		ret
; End of function sub_8D7


; =============== S U B	R O U T	I N E =======================================


sub_95D:					; CODE XREF: u_Modulation+4Aj
						; u_PlayNote+14p
		push	hl
		ld	l, (ix+9)
		ld	h, (ix+0Ah)
		ld	(ix+47h), l
		ld	(ix+48h), h
		pop	hl
		ld	a, (ix+2Bh)
		and	1
		jr	z, loc_984
		ld	a, (word_2B)
		or	a
		jr	z, loc_984
		ld	a, (CurrentChannel)
		cp	6			; is chanel number above 6 (FM)?
		jr	c, loc_984		; if yes, branch
		ld	a, (byte_1D)
		or	a
		ret	z

loc_984:					; CODE XREF: sub_95D+13j
						; sub_95D+19j ...
		push	hl
		push	de
		push	bc
		ld	a, (ix+0Ah)
		ld	bc, 0CFFh

loc_98D:					; CODE XREF: sub_95D+32j
		inc	c
		sub	b
		jp	nc, loc_98D
		add	a, b
		ld	b, a
		ld	a, (CurrentChannel)
		cp	6			; is channel above 6 (FM)?
		jp	c, u_CalcFMFreq		; if yes, branch
		sub	6
		add	a, a
		add	a, 8
		add	a, a
		add	a, a
		add	a, a
		add	a, a
		ld	(byte_1F7A), a
		ld	a, b
		add	a, a
		ld	e, a
		ld	d, 0
		ld	hl, PSG_Frequencies
		add	hl, de
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		ld	a, c
		cp	2
		jr	nc, loc_9BB
		ld	a, 2

loc_9BB:					; CODE XREF: sub_95D+5Aj
		sub	2
		ld	c, a
		ld	a, b
		push	bc
		add	a, a
		add	a, a
		add	a, a
		add	a, a
		ld	l, a
		ld	h, 0
		ld	b, h
		add	hl, hl
		ld	c, (ix+9)		; load portamento counter
		add	hl, bc
		ld	bc, PSG_PortamentoFreq
		add	hl, bc
		ld	l, (hl)
		ld	h, 0
		ex	de, hl
		or	a
		sbc	hl, de
		ex	de, hl
		pop	bc
		ld	a, c
		or	a
		jp	z, loc_9E6
		ld	b, a

loc_9E0:					; CODE XREF: sub_95D+87j
		srl	d
		rr	e
		djnz	loc_9E0

loc_9E6:					; CODE XREF: sub_95D+7Fj
		ld	a, e
		sla	e
		rl	d
		sla	e
		rl	d
		sla	e
		rl	d
		sla	e
		rl	d
		and	0Fh
		ld	e, a
		ld	a, d
		and	3Fh
		ld	h, a
		ld	a, (byte_1F7A)
		or	e
		call	WritePSGData2		; a = Data, h =	Data2
		jp	loc_A50
; ---------------------------------------------------------------------------

u_CalcFMFreq:					; CODE XREF: sub_95D+3Cj
		ld	h, 3			; something to do with FM frequencies
						; b = Note
		sub	h
		ccf
		adc	a, h
		and	h			; FM1-FM3 -> 0..2, FM4-FM6 -> 0..2
		add	a, 0A4h			; a = YM Frequency register for	this channel
		ld	(u_RegisterByte), a	; remember it
		ld	a, b			; a = Note
		add	a, a			; a = Note*2
		ld	e, a
		ld	d, 0			; de = Note*2
		ld	hl, FM_Frequencies
		add	hl, de			; hl = FM_Frequencies +	Note*2
		ld	e, (hl)
		inc	hl
		ld	d, (hl)			; de = Frequency
		push	bc
		add	a, a			; a = Note*4
		add	a, a			; a = Note*8
		add	a, a			; a = Note*16
		ld	l, a
		ld	h, 0			; hl = Note*16
		ld	b, h
		add	hl, hl			; hl = Note*32
		ld	c, (ix+9)		; c = Portamento counter
		add	hl, bc			; hl = Note*32 + Portamento
		ld	bc, FM_PortamentoFreq
		add	hl, bc			; hl = FM_PortamentoFreq + (Note*32+Portamento)
		ld	l, (hl)
		ld	h, 0			; hl = Portamento Frequency Gain
		ex	de, hl
		add	hl, de
		ex	de, hl			; de = Note Frequency +	Portamento
		pop	bc			; c = Ocatave
		sla	c
		sla	c
		sla	c			; c = c<<3
		ld	a, d
		or	c
		ld	d, a			; d = (Octave<<3) | (Frequency Hi-byte)
		ld	a, (u_RegisterByte)
		ld	h, a			; h = YM Frequency Hi-byte Register (0A4h+)
		ld	a, d			; a = Frequency	Hi-byte
		call	WriteFMData		; h = Register,	a = Value
		ld	a, h
		sub	4
		ld	h, a			; h = YM Frequency Lo-Byte (0A0h+)
		ld	a, e			; a = Frequency	Lo-byte
		call	WriteFMData		; h = Register,	a = Value

loc_A50:					; CODE XREF: sub_95D+A8j
		pop	bc
		pop	de
		pop	hl
		ret
; End of function sub_95D


; =============== S U B	R O U T	I N E =======================================


sub_A54:					; CODE XREF: UpdateBGMChannel+Ep
		ld	a, (byte_2D)
		or	a
		ret	z
		ld	a, (byte_1D)
		or	a
		jr	z, loc_A64
		dec	a
		ld	(byte_1D), a
		ret
; ---------------------------------------------------------------------------

loc_A64:					; CODE XREF: sub_A54+9j
		ld	a, (byte_32)
		dec	a
		ld	(byte_32), a
		ret	nz
		ld	l, 0
		ld	a, (word_2B)
		ld	b, a
		ld	a, (word_29)
		inc	a
		cp	b
		jr	c, loc_A7B
		ld	a, b
		inc	l

loc_A7B:					; CODE XREF: sub_A54+23j
		ld	(word_29), a
		ld	a, (word_2B+1)
		ld	b, a
		ld	a, (word_29+1)
		inc	a
		cp	b
		jr	c, loc_A8B
		ld	a, b
		inc	l

loc_A8B:					; CODE XREF: sub_A54+33j
		ld	(word_29+1), a
		ld	a, l
		cp	2
		jr	nz, loc_A98
		xor	a
		ld	(byte_2D), a
		ret
; ---------------------------------------------------------------------------

loc_A98:					; CODE XREF: sub_A54+3Dj
		ld	a, (byte_2D)
		ld	(byte_32), a
		ret
; End of function sub_A54


; =============== S U B	R O U T	I N E =======================================


u_Modulation:					; CODE XREF: UpdateBGMChannel+16p
						; sub_10D7+Ep
		ld	e, (ix+0Dh)
		ld	d, (ix+0Eh)
		ld	a, d
		or	e
		ret	z
		ld	l, (ix+9)
		ld	h, (ix+0Ah)
		sla	l
		sla	l
		sla	l
		add	hl, de
		ld	(ix+9),	l
		ld	(ix+0Ah), h
		ld	c, (ix+0Bh)
		ld	b, (ix+0Ch)
		sla	c
		sla	c
		sla	c
		or	a
		sbc	hl, bc
		ld	a, h
		xor	d
		jp	m, loc_ADE
		ld	(ix+9),	c
		ld	(ix+0Ah), b
		ld	de, 0
		ld	(ix+0Dh), e
		ld	(ix+0Eh), d

loc_ADE:					; CODE XREF: u_Modulation+2Dj
		ld	a, (ix+9)
		rrca
		rrca
		rrca
		and	1Fh
		ld	(ix+9),	a
		jp	sub_95D
; End of function u_Modulation


; =============== S U B	R O U T	I N E =======================================


TimeredInterrupts:				; CODE XREF: ROM:00D1p
		ld	a, (YM_Port0_Reg)	; read YM state
		rrca
		call	c, Interrupt_Modulation	; if Timer B finished, call
		rrca
		call	c, Interrupt_BGMUpdate	; if Timer A finished, call
		ret
; End of function TimeredInterrupts


; =============== S U B	R O U T	I N E =======================================


Interrupt_Modulation:				; CODE XREF: TimeredInterrupts+4p
		push	af
		call	UpdateModulation
		ld	h, 27h
		ld	a, 1Fh
		call	Write_YM_Port0		; YM ->	Clear Timer B overflow flag
		pop	af
		ret
; End of function Interrupt_Modulation


; =============== S U B	R O U T	I N E =======================================


Interrupt_BGMUpdate:				; CODE XREF: TimeredInterrupts+8p
		push	af
		ld	hl, (BGM_ChannelsPlaying)
		ld	a, h
		or	l			; are any of BGM channels playing?
		call	nz, UpdateBGM		; if yes, branch
		ld	h, 27h
		ld	a, 2Fh
		call	Write_YM_Port0		; YM ->	Clear Timer A overflow flag
		pop	af
		ret
; End of function Interrupt_BGMUpdate


; =============== S U B	R O U T	I N E =======================================


DriverInterrupt:				; CODE XREF: j_DriverInterruptj
		di
		push	af
		in	a, (0BFh)		; does this even make sense?
		push	hl
		push	de
		push	bc
		push	ix
		push	iy
		ld	hl, (SFX_ChannelsPlaying) ; load currently playing channels in SFX
		ld	a, h
		or	l			; are any SFX channels playing?
		jr	z, UpdateBGM		; if not, branch
		ld	(SFX_Playing), a
		ld	de, (u_ChanNum)
		ld	(word_198A), de
		ld	de, 0FFFFh
		ld	(u_ChanNum), de
		ld	ix, FM1_SFX_Struct
		ld	de, 54h			; de = Channel size
		xor	a
		call	sub_B92
		ld	hl, (word_198A)
		ld	(u_ChanNum), hl
		ld	hl, (SFX_ChannelsPlaying)
		ld	a, h
		or	l
		jr	nz, UpdateBGM
		ld	a, (byte_16)
		or	a
		jp	p, UpdateBGM
		and	7
		or	0E0h
		call	WritePSGData		; a = Data

UpdateBGM:					; CODE XREF: DriverInterrupt+10j
						; DriverInterrupt+3Aj ...
		xor	a
		ld	(SFX_Playing), a
		ld	hl, (BGM_ChannelsPlaying) ; load currently playing BGM channels
		ld	a, h
		or	l			; are any channels in BGM playing?
		jr	z, Interrupt_End	; if not, branch
		ld	a, (FadeOutSpeed)	; load fade out	speed
		or	a
		jr	z, Interrupt_End	; if speed isn't set, quit
		ld	hl, FadeOutCounter	; load fade out	counter
		dec	(hl)			; decrease it
		jr	nz, Interrupt_End	; if not zero, branch
		ld	(hl), a			; otherwise, reset it to the speed value
		ld	hl, FadeOutVolume	; load current global volume level
		inc	(hl)			; increase it
		ld	a, (hl)
		cp	7Fh			; is it	7Fh?
		jr	nz, Interrupt_End	; if not, brach
		xor	a
		ld	h, a
		ld	l, h
		ld	(BGM_ChannelsPlaying), hl ; mark all BGM channels as stopped

Interrupt_End:					; CODE XREF: DriverInterrupt+53j
						; DriverInterrupt+59j ...
		pop	iy
		pop	ix
		pop	bc
		pop	de
		pop	hl
		pop	af
		ei
		ret
; End of function DriverInterrupt


; =============== S U B	R O U T	I N E =======================================


sub_B92:					; CODE XREF: DriverInterrupt+2Cp
		ld	b, 9

loc_B94:					; CODE XREF: sub_B92+Cj
		srl	h
		rr	l			; hl = hl>>1
		call	c, sub_10D7		; if the bit carried out is 1, call
		add	ix, de			; next channel
		inc	a			; next channel num
		djnz	loc_B94			; repeat for 9 channels
		ret
; End of function sub_B92


; =============== S U B	R O U T	I N E =======================================


UpdateModulation:				; CODE XREF: Interrupt_Modulation+1p
		push	de
		push	bc
		push	ix
		ld	de, 54h			; de = Channel size
		xor	a
		ld	(SFX_Playing), a	; clear	SFX playing flag
		ld	ix, PSG1_BGM_Struct
		call	u_PSG_Update		; Maybe	updates	PSG channels
		ld	a, 0FFh
		ld	(SFX_Playing), a	; set SFX playing flag
		ld	ix, PSG1_SFX_Struct
		call	u_PSG_Update		; Maybe	updates	PSG channels
		xor	a
		ld	(SFX_Playing), a	; clear	SFX playing flag
		di
		ld	hl, (BGM_ChannelsPlaying)
		ld	a, h
		or	l			; are any BGM channels playing?
		call	nz, u_LFO_Proc		; if yes, call
		ei
		pop	ix
		pop	bc
		pop	de
		ret
; End of function UpdateModulation


; =============== S U B	R O U T	I N E =======================================

; Maybe	updates	PSG channels

u_PSG_Update:					; CODE XREF: UpdateModulation+Fp
						; UpdateModulation+1Bp
		ld	b, 3
		ld	a, 6

loc_BD6:					; CODE XREF: u_PSG_Update+Cj
		di
		call	sub_1475
		ei
		add	ix, de			; next channel
		inc	a			; next channel num
		djnz	loc_BD6			; repeat 3 times
		ret
; End of function u_PSG_Update

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR u_LFO_Proc

loc_BE1:					; CODE XREF: u_LFO_Proc+2Cj
		ld	a, (CurrentChannel)
		push	af
		ld	ix, FM1_BGM_Struct
		ld	de, 54h			; de = Channel size
		ld	b, 6
		xor	a

loc_BEF:					; CODE XREF: u_LFO_Proc-984j
		call	sub_153E
		inc	a			; next channel number
		add	ix, de			; next channel struct
		djnz	loc_BEF			; repeat 6 times (for all FMs)
		pop	af
		ld	(CurrentChannel), a
		ret
; END OF FUNCTION CHUNK	FOR u_LFO_Proc

; =============== S U B	R O U T	I N E =======================================

; Input:
; hl = 9-bit field of BGM channels playing

UpdateBGM:					; CODE XREF: Interrupt_BGMUpdate+6p
		push	de
		push	bc
		push	ix
		ld	ix, FM1_BGM_Struct
		xor	a
		ld	(SFX_Playing), a	; clear	SFX playing flag
		ld	de, 54h			; de = Channel size
		ld	b, 9

BGMChannelsLoop:				; CODE XREF: UpdateBGM+1Dj
		di
		srl	h
		rr	l			; hl = hl>>1
		call	c, UpdateBGMChannel	; if this channel's playing, call
		ei
		add	ix, de			; next channel
		inc	a			; next channel number
		djnz	BGMChannelsLoop		; repeat 9 times (for 6	FMs and	3 PSGs)
		pop	ix
		pop	bc
		pop	de
		ret
; End of function UpdateBGM


; =============== S U B	R O U T	I N E =======================================


LoadSFX:					; DATA XREF: ROM:CommandsTableo
		ld	bc, (Input)
		xor	a
		ld	(Command), a		; clear	command
		ld	a, c
		di
		inc	b
		jp	z, loc_CF4		; if first input byte 0FFh, branch
		ld	hl, (Offset_SFX)
		ld	d, h
		ld	e, l			; de = SFX table offset
		inc	hl
		cp	(hl)
		jp	nc, loc_CF4		; if no, branch
		push	bc
		ld	c, a
		ld	b, 0
		ld	hl, 8
		add	hl, bc
		add	hl, bc			; hl = SFX*2 + 8
		add	hl, de			; hl = SFX Offset + SFX*2 + 8
		ld	a, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, a			; hl = SFX relative offset
		add	hl, de			; hl = SFX offset
		ld	iy, FM1_BGM_Struct
		ld	ix, FM1_SFX_Struct
		ld	de, (u_ChanNum)
		ld	(word_198A), de
		ld	de, 0FFFFh
		ld	(u_ChanNum), de
		pop	bc
		ld	a, 0FFh
		ld	(SFX_Playing), a	; set SFX playing flag
		cpl				; a = 0
		ld	(CurrentChannel), a	; set current channel to 0
		ld	a, (hl)			; load number of channels
		inc	hl			; next SFX data	byte
		push	af

loc_C6B:					; CODE XREF: LoadSFX+B3j
		ld	a, (CurrentChannel)	; load current channel
		cp	(hl)			; is it	present	in SFX?
		jr	nz, NextChannel		; if not, branch
		ld	c, a
		ld	a, (ix+0)
		or	a
		jr	z, loc_C7B
		cp	b
		jr	c, loc_CD5

loc_C7B:					; CODE XREF: LoadSFX+56j
		ld	(ix+0),	b
		ld	a, c
		push	bc
		cp	8			; is this channel 8 (PSG3)?
		jr	nz, SetChannelPlaying	; if not, branch
		ld	a, 1			; set PSG 3 as playing
		ld	(SFX_ChannelsPlaying+1), a
		jr	loc_C9A
; ---------------------------------------------------------------------------

SetChannelPlaying:				; CODE XREF: LoadSFX+62j
		ld	c, 80h
		inc	a
		ld	b, a

FindChannel:					; CODE XREF: LoadSFX+71j
		rlc	c
		djnz	FindChannel		; repeat until bit in 'c' is in right position
		ld	a, (SFX_ChannelsPlaying)
		or	c
		ld	(SFX_ChannelsPlaying), a

loc_C9A:					; CODE XREF: LoadSFX+69j
		inc	hl			; next SFX data	byte
		ld	a, (CurrentChannel)
		push	af
		ld	(iy+0),	0FFh		; disable corresponding	channel	in BGM
		call	InitChannel		; create SFX channel
		pop	af
		ld	a, (iy+1Ch)
		or	a
		jr	z, loc_CB2
		push	hl
		call	FlagF2
		pop	hl

loc_CB2:					; CODE XREF: LoadSFX+8Bj
		call	sub_FBB
		call	sub_1412
		pop	bc
		pop	af
		dec	a
		jr	z, loc_CEC
		push	af

NextChannel:					; CODE XREF: LoadSFX+4Fj
						; LoadSFX+C1j
		ld	a, (CurrentChannel)	; load current channel
		inc	a			; increase it
		cp	9			; have all channels been done?
		jr	nz, loc_CC9		; if not, branch
		pop	af
		jr	loc_CEC
; ---------------------------------------------------------------------------

loc_CC9:					; CODE XREF: LoadSFX+A4j
		ld	de, 54h			; de = Channel size
		add	ix, de
		add	iy, de
		ld	(CurrentChannel), a
		jr	loc_C6B
; ---------------------------------------------------------------------------

loc_CD5:					; CODE XREF: LoadSFX+59j
						; LoadSFX+C8j ...
		ld	a, (hl)
		inc	hl
		cp	0E0h
		jr	nc, loc_CE3
		inc	hl
		pop	af
		dec	a
		jr	z, loc_CEC
		push	af
		jr	NextChannel
; ---------------------------------------------------------------------------

loc_CE3:					; CODE XREF: LoadSFX+B9j
		cp	0F0h
		jr	nc, loc_CEA
		inc	hl
		jr	loc_CD5
; ---------------------------------------------------------------------------

loc_CEA:					; CODE XREF: LoadSFX+C5j
		jr	loc_CD5
; ---------------------------------------------------------------------------

loc_CEC:					; CODE XREF: LoadSFX+9Bj
						; LoadSFX+A7j ...
		ld	de, (word_198A)
		ld	(u_ChanNum), de

loc_CF4:					; CODE XREF: LoadSFX+Bj
						; LoadSFX+15j
		ei
		ret
; End of function LoadSFX

; ---------------------------------------------------------------------------

LoadBGM:					; DATA XREF: ROM:CommandsTableo
		ld	a, (Input+1)
		ld	e, a
		ld	d, 0			; de = BMG Number (inside current bank)
		ld	hl, ROMBank		; load music offsets table
		add	hl, de
		add	hl, de			; add BGM number to it
		ld	d, (hl)
		inc	hl
		ld	e, (hl)			; de = BGM Offset
		set	7, d			; ensure the offset is 8000h based
		ld	a, (de)
		cp	9			; is header 09h?
		jp	nz, ResetCommand	; if not, finish executing command
		ld	(Offset_BGM), de	; save BGM offset

LoadBGM2:					; DATA XREF: ROM:CommandsTableo
		di
		ld	a, (Input)
		ld	(BGM_LoopFlag),	a	; set loop flag	acroding to input
		xor	a
		ld	(SFX_Playing), a	; clear	SFX playing flag
		ld	(Command), a		; clear	command
		call	InitBGMPlayback
		call	LoadBGMTracks
		ei
		ret
; ---------------------------------------------------------------------------

u_StopSFX:					; DATA XREF: ROM:CommandsTableo
		call	ResetCommand
		di
		ld	bc, (SFX_ChannelsPlaying)
		ld	a, b
		or	c
		jp	z, loc_DC6
		ld	hl, 0
		ld	(SFX_ChannelsPlaying), hl
		ld	de, (BGM_ChannelsPlaying)
		ld	ix, FM1_BGM_Struct
		ld	iy, FM1_SFX_Struct
		xor	a
		ld	h, 9

loc_D48:					; CODE XREF: ROM:0DB5j
		ld	(CurrentChannel), a
		srl	b
		rr	c
		jr	nc, loc_DA3
		push	bc
		push	hl
		push	de
		ld	a, 0FFh
		ld	(SFX_Playing), a
		push	ix
		push	iy
		pop	ix
		call	StopTrack		; something to do with 'key off'?
		xor	a
		ld	(ix+3Ch), a
		call	sub_8AF
		ld	a, (ix+1Ch)
		or	a
		call	nz, FlagF2
		ld	(ix+0),	0
		pop	ix
		ld	a, (CurrentChannel)
		ld	(ix+0),	0
		pop	de
		ld	a, e
		and	1
		jr	z, loc_DA1
		xor	a
		ld	(SFX_Playing), a
		push	de
		ld	c, (ix+1Dh)
		call	LoadInstrument		; Input:
						; c = Instrument Number
		call	loc_984
		ld	a, (ix+1Ch)
		or	a
		call	nz, FlagF3
		ld	a, (ix+2Bh)
		and	1
		call	nz, sub_13F5
		pop	de

loc_DA1:					; CODE XREF: ROM:0D81j
		pop	hl
		pop	bc

loc_DA3:					; CODE XREF: ROM:0D4Fj
		exx
		ld	de, 54h
		add	ix, de
		add	iy, de
		exx
		srl	d
		rr	e
		ld	a, (CurrentChannel)
		inc	a
		dec	h
		jp	nz, loc_D48
		ld	a, (byte_16)
		or	a
		jp	p, loc_DC6
		and	7
		or	0E0h ; 'à'
		call	WritePSGData		; a = Data

loc_DC6:					; CODE XREF: ROM:0D30j
						; ROM:0DBCj
		ei
		ret
; ---------------------------------------------------------------------------

FadeOutBGM:					; DATA XREF: ROM:CommandsTableo
		ld	hl, 3
		ld	a, (Input)
		ld	(hl), 0
		di
		ld	(FadeOutSpeed),	a
		ld	(FadeOutCounter), a
		or	a
		jr	nz, loc_E0C
		ld	h, a
		ld	l, a
		ld	(BGM_ChannelsPlaying), hl
		ld	(SFX_Playing), a
		ld	ix, FM1_BGM_Struct
		ld	b, 9
		ld	hl, 0Fh
		ld	(hl), a

loc_DEC:					; CODE XREF: ROM:0E0Aj
		push	hl
		push	bc
		bit	7, (ix+1Eh)
		call	nz, StopTrack		; something to do with 'key off'?
		ld	a, b
		cp	3
		jr	nc, loc_DFE
		ld	(ix+41h), 0

loc_DFE:					; CODE XREF: ROM:0DF8j
		xor	a
		call	u_UpdateFMVolume
		pop	bc
		pop	hl
		inc	(hl)
		ld	de, 54h			; de = Channel size
		add	ix, de			; next channel struct
		djnz	loc_DEC

loc_E0C:					; CODE XREF: ROM:0DD8j
		ei
		ret

; =============== S U B	R O U T	I N E =======================================


InitBGMPlayback:				; CODE XREF: ROM:0D1Ep
		push	hl
		push	de
		push	af
		ld	de, (Offset_BGM)	; load BGM offset
		ld	hl, 1
		add	hl, de			; hl = BGM volume byte offset
		ld	a, (hl)			; load volume byte
		ld	(BGM_Volume), a		; save it
		inc	hl
		ld	a, (hl)			; load tempo modifier
		ld	(BGM_Tempo), a		; save it
		inc	hl
		ld	a, (hl)			; load pitch modifier
		ld	(BGM_Pitch), a		; save it
		ld	a, (BGM_Tempo)
		call	SetTimerB
		xor	a
		ld	(FadeOutVolume), a	; reset	global volume
		ld	(FadeOutSpeed),	a	; reset	fade out speed
		ld	(byte_16), a
		ld	(byte_15), a
		ld	(byte_1C), a
		cpl
		ld	(u_ChanNum), a
		ld	(u_ChanNum+1), a
		pop	af
		pop	de
		pop	hl
		ret
; End of function InitBGMPlayback


; =============== S U B	R O U T	I N E =======================================


LoadBGMTracks:					; CODE XREF: ROM:0D21p
		push	af
		push	hl
		push	de
		push	bc
		push	ix
		ld	ix, FM1_BGM_Struct
		ld	hl, 6
		ld	de, (Offset_BGM)	; de = BGM Offset
		add	hl, de			; hl = BGM Offset + 6
		ld	a, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, a			; hl = Tracks table relative offset
		add	hl, de			; hl = Tracks table offset
		ld	bc, 1FFh
		ld	(BGM_ChannelsPlaying), bc ; mark all 9 channels	as playing
		xor	a
		ld	b, 9

LoadBGMChannel:					; CODE XREF: LoadBGMTracks+54j
		push	af
		push	bc
		ld	(CurrentChannel), a
		push	hl			; save channels	offset table pointer
		ld	a, (hl)
		inc	hl
		ld	h, (hl)			; load relative	offset for this	channel
		ld	l, a
		ld	de, (Offset_BGM)
		add	hl, de			; calculate absolute offset
		call	InitChannel
		ld	(ix+3),	l
		ld	(ix+4),	h		; save track offset in BGM to word 03h
		call	RunBGMTrack
		cp	0FFh			; is the last byte processed 0FFh?
		jr	nz, Track_NoReset	; if not, branch
		ld	de, 0
		ld	(ix+5),	e
		ld	(ix+6),	d		; set current position in pattern to zero

Track_NoReset:					; CODE XREF: LoadBGMTracks+3Ej
		pop	hl
		inc	hl
		inc	hl
		ld	de, 54h			; de = Channel size
		add	ix, de			; next channel struct
		pop	bc
		pop	af
		inc	a			; next channel number
		djnz	LoadBGMChannel		; repeat 9 times for all FM and	PSG channels
		pop	ix
		pop	bc
		pop	de
		pop	hl
		pop	af
		ret
; End of function LoadBGMTracks


; =============== S U B	R O U T	I N E =======================================


InitChannel:					; CODE XREF: LoadSFX+83p
						; LoadBGMTracks+30p
		push	af
		push	hl
		push	de
		push	bc
		push	hl
		ld	a, (ix+1Ch)
		or	a
		jr	z, loc_EB4
		xor	a			; mute channel
		call	u_UpdateFMVolume

loc_EB4:					; CODE XREF: InitChannel+9j
		push	ix
		pop	hl			; hl = ix
		inc	hl			; hl = ix+1
		ld	d, h			; de = ix+1
		ld	e, l			; ''
		inc	de			; de = ix+2
		ld	bc, 52h
		ld	(hl), 0			; (ix+1)=0
		ldir				; clear	channel	struct (53h bytes, starting from offset	01h)
		call	ResetChannelStack
		pop	hl			; hl = Track offset in BGM
		ld	(ix+1),	l
		ld	(ix+2),	h		; save this offset to word 01h
		ld	(ix+2Ch), 0C0h
		ld	c, 0
		call	sub_6A3
		ld	(ix+1Fh), 1
		ld	(ix+31h), 1
		pop	bc
		pop	de
		pop	hl
		pop	af
		ret
; End of function InitChannel


; =============== S U B	R O U T	I N E =======================================


ResetChannelStack:				; CODE XREF: InitChannel+1Dp
						; RunPattern+25p
		push	hl
		push	de
		push	ix
		pop	hl			; hl = ix
		ld	de, 0Fh
		add	hl, de			; hl = ix + 0Fh	(Stack current level)
		ld	(hl), 0			; reset	stack level
		inc	hl			; hl = ix + 10h	(Initial stack pointer)
		ld	(ix+7),	l
		ld	(ix+8),	h		; reset	stack position
		pop	de
		pop	hl
		ret
; End of function ResetChannelStack


; =============== S U B	R O U T	I N E =======================================


LoadTrackByte:					; CODE XREF: RunBGMTrack:Track_FetchBytep
						; sub_FBB:loc_FBDp ...
		push	hl
		ld	a, (hl)			; load a byte from track
		cp	0E0h			; is this coordination flag?
		jr	c, Track_Done		; if not, branch
		cp	0EEh			; is this flag 0E0h..0EDh?
		jr	nc, ChkCoordFlag	; if not, branch
		call	CoordFlag		; execute flag
		jr	Track_Done2Bytes
; ---------------------------------------------------------------------------

ChkCoordFlag:					; CODE XREF: LoadTrackByte+8j
		cp	0F0h			; is this coordination flag 0EEh..0EFh?
		jr	c, Track_Done2Bytes	; if yes, branch
		cp	0F8h			; is this coordination flag 0F0h..0F7h?
		jr	nc, ChkSpecFlag		; if not, branch
		call	CoordFlag_NoArg		; execute flag
		jr	Track_Done1Byte
; ---------------------------------------------------------------------------

ChkSpecFlag:					; CODE XREF: LoadTrackByte+15j
		cp	0FBh			; is this coordination flag 0FBh..0FFh?
		jr	nc, Track_Done		; if yes, branch

Track_Done1Byte:				; CODE XREF: LoadTrackByte+1Aj
		pop	hl			; restore track	offset
		inc	hl			; go 1 byte forward
		xor	a			; return 0
		ret
; ---------------------------------------------------------------------------

Track_Done2Bytes:				; CODE XREF: LoadTrackByte+Dj
						; LoadTrackByte+11j
		pop	hl			; restore track	offset
		inc	hl			; go 2 bytes forward
		inc	hl			; ''
		xor	a			; return 0
		ret
; ---------------------------------------------------------------------------

Track_Done:					; CODE XREF: LoadTrackByte+4j
						; LoadTrackByte+1Ej
		pop	hl			; restore track	offset
		ret	c			; if it's not a flag, return
		or	a			; return a
		ret
; End of function LoadTrackByte

; ---------------------------------------------------------------------------
		ret				; unused/overwritten code

; =============== S U B	R O U T	I N E =======================================


MarkTrackStop:					; CODE XREF: RunBGMTrack+1Fp
						; UpdateBGMChannel+72p
		ld	a, (CurrentChannel)
		cp	8			; is this channel 8 (PSG3)?
		jr	nz, MarkStop_CalcBit
		xor	a
		ld	(BGM_ChannelsPlaying+1), a ; clear bit 9
		ret
; ---------------------------------------------------------------------------

MarkStop_CalcBit:				; CODE XREF: MarkTrackStop+5j
		ld	b, a			; b = Channel
		inc	b			; b = Channel+1
		ld	c, 7Fh			; c = %01111111

MarkStop_FindBit:				; CODE XREF: MarkTrackStop+12j
		rlc	c			; rotate c until bit 0 in it reaches right position
		djnz	MarkStop_FindBit	; repeat
		ld	a, (BGM_ChannelsPlaying) ; load	currently playing channels bitfield
		and	c			; clear	this channel's bit
		ld	(BGM_ChannelsPlaying), a ; save	it
		ret
; End of function MarkTrackStop


; =============== S U B	R O U T	I N E =======================================


SetBGMChannelPlaying:				; CODE XREF: UpdateBGMChannel+87p
		ld	a, (CurrentChannel)
		cp	8
		jr	nz, loc_F4E
		ld	a, 1
		ld	(BGM_ChannelsPlaying+1), a
		ret
; ---------------------------------------------------------------------------

loc_F4E:					; CODE XREF: SetBGMChannelPlaying+5j
		ld	b, a
		inc	b
		ld	c, 80h

loc_F52:					; CODE XREF: SetBGMChannelPlaying+13j
		rlc	c
		djnz	loc_F52
		ld	a, (BGM_ChannelsPlaying)
		or	c
		ld	(BGM_ChannelsPlaying), a
		ret
; End of function SetBGMChannelPlaying


; =============== S U B	R O U T	I N E =======================================

; Input:
; hl = Track current position
;
; Output:
; a = Last processed byte in track

RunBGMTrack:					; CODE XREF: LoadBGMTracks+39p
						; UpdateBGMChannel:loc_1095p
		push	hl
		push	de
		push	bc
		ld	l, (ix+1)
		ld	h, (ix+2)		; hl = Channel's track offset in BGM

Track_FetchByte:				; CODE XREF: RunBGMTrack+31j
		call	LoadTrackByte
		jr	c, LoadPattern		; if byte = 00h..0DFh, load corresponding pattern
		jr	z, NextTrackByte	; if flag was processed, repeat
		push	hl
		cp	0FDh			; is flag 0FDh issued?
		jr	nz, ChkFlagFF		; if not, branch
		call	SetTrackRestartPos
		jr	IgnoreFlag
; ---------------------------------------------------------------------------

ChkFlagFF:					; CODE XREF: RunBGMTrack+13j
		cp	0FFh			; is flag 0FFh issued (end of track)?
		jr	nz, IgnoreFlag		; if not, branch
		push	af
		call	MarkTrackStop
		call	StopTrack		; something to do with 'key off'?
		pop	af
		pop	hl
		jr	loc_FB7
; ---------------------------------------------------------------------------

IgnoreFlag:					; CODE XREF: RunBGMTrack+18j
						; RunBGMTrack+1Cj
		pop	hl
		inc	hl

NextTrackByte:					; CODE XREF: RunBGMTrack+Ej
		ld	(ix+1),	l
		ld	(ix+2),	h		; save current position	in track
		jr	Track_FetchByte		; do next byte
; End of function RunBGMTrack


; =============== S U B	R O U T	I N E =======================================

; Input:
; a - Pattern number

LoadPattern:					; CODE XREF: RunBGMTrack+Cj
		push	hl
		ld	c, a
		ld	b, 0			; bc = Pattern
		ld	de, (Offset_BGM)	; de = Offset_BGM
		ld	hl, 8
		add	hl, de			; hl = Offset_BGM + 8
		ld	a, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, a			; hl = Patterns	Table relative offset
		add	hl, de			; hl = Patterns	table absolute offset
		add	hl, bc
		add	hl, bc			; hl = Pattern table entry offset for this pattern
		ld	c, (hl)
		inc	hl
		ld	b, (hl)			; bc = Pattern offset
		ex	de, hl			; hl = Offset_BGM
		add	hl, bc			; hl = Offset_BGM + Pattern offset
		ld	(ix+5),	l
		ld	(ix+6),	h		; save pattern offset
		pop	hl
		inc	hl			; increase track position
		ld	(ix+1),	l
		ld	(ix+2),	h		; save current track position

loc_FB7:					; CODE XREF: RunBGMTrack+27j
		pop	bc
		pop	de
		pop	hl
		ret
; End of function LoadPattern


; =============== S U B	R O U T	I N E =======================================


sub_FBB:					; CODE XREF: LoadSFX:loc_CB2p
		push	de
		push	bc

loc_FBD:					; CODE XREF: sub_FBB+7j
						; sub_FBB+Aj
		call	LoadTrackByte
		jr	c, loc_FC7
		jr	z, loc_FBD		; if flag was processed, repeat
		inc	hl
		jr	loc_FBD
; ---------------------------------------------------------------------------

loc_FC7:					; CODE XREF: sub_FBB+5j
		ld	d, a
		inc	hl
		ld	e, (hl)
		inc	hl
		push	hl
		ld	hl, (Offset_SFX)
		add	hl, de
		ld	(ix+5),	l
		ld	(ix+6),	h
		pop	hl
		pop	bc
		pop	de
		ret
; End of function sub_FBB


; =============== S U B	R O U T	I N E =======================================


RunPattern:					; CODE XREF: UpdateBGMChannel+4Bp
						; sub_10D7:loc_1115p
		push	hl
		ld	l, (ix+5)
		ld	h, (ix+6)		; hl = Current position	in pattern

Pattern_FetchByte:				; CODE XREF: RunPattern+1Fj
						; RunPattern+33j
		call	LoadTrackByte
		jr	c, Pattern_LoadNote	; if byte = 00h..DFh, branch
		jr	z, Pattern_NextByte
		push	hl
		cp	0FDh			; is this flag 0FDh (repeat)?
		jr	nz, loc_FFB		; if not, branch
		call	RepeatTrack		; repeat track given number of times
		jr	c, Pattern_SetNextByte	; if repeating is over,	branch
		pop	hl
		ld	l, (ix+5)		; hl = Pattern's new position
		ld	h, (ix+6)
		jr	Pattern_FetchByte
; ---------------------------------------------------------------------------

loc_FFB:					; CODE XREF: RunPattern+11j
		cp	0FFh			; is this flag 0FFh (end of track)?
		jr	nz, Pattern_SetNextByte	; if not, branch
		call	ResetChannelStack
		pop	hl
		jr	Pattern_Finished
; ---------------------------------------------------------------------------

Pattern_SetNextByte:				; CODE XREF: RunPattern+16j
						; RunPattern+23j
		pop	hl
		inc	hl

Pattern_NextByte:				; CODE XREF: RunPattern+Cj
		ld	(ix+5),	l
		ld	(ix+6),	h
		jr	Pattern_FetchByte
; ---------------------------------------------------------------------------

Pattern_LoadNote:				; CODE XREF: RunPattern+Aj
		sub	80h			; subtract 80h from byte
		inc	hl			; next byte in pattern
		push	af
		ld	e, (ix+32h)
		ld	d, (ix+33h)
		ld	c, (ix+34h)
		ld	a, (hl)			; load a byte from pattern
		or	a
		jp	m, Pattern_Done		; if byte = 80h..0FFh, branch
		inc	hl			; next byte in pattern
		ld	(ix+32h), a
		ld	e, a
		ld	a, (hl)			; load a byte from pattern
		or	a
		jp	m, Pattern_Done		; if byte = 80h..0FFh, branch
		inc	hl			; next byte in pattern
		ld	(ix+33h), a
		ld	d, a
		ld	a, (hl)			; load a byte from pattern
		or	a
		jp	m, Pattern_Done		; if byte = 80h..0FFh, branch
		inc	hl			; next byte in pattern
		ld	(ix+34h), a
		ld	c, a

Pattern_Done:					; CODE XREF: RunPattern+44j
						; RunPattern+4Ej ...
		ld	(ix+5),	l		; save current position	in pattern
		ld	(ix+6),	h
		pop	af

Pattern_Finished:				; CODE XREF: RunPattern+29j
		pop	hl
		ret
; End of function RunPattern


; =============== S U B	R O U T	I N E =======================================

; Input:
; a = Channel number
; ix = Channel struct

UpdateBGMChannel:				; CODE XREF: UpdateBGM+16p
		push	af
		push	hl
		push	de
		push	bc
		and	0Fh
		ld	(CurrentChannel), a
		ld	c, a
		ld	a, (u_ChanNum)
		cp	c
		call	z, sub_A54
		ld	a, (ix+23h)		; load portamento setting
		and	7Fh
		call	nz, u_Modulation	; if active, call
		ld	a, (ix+29h)		; load volume effect setting
		or	a
		call	nz, u_VolumeEffect	; if active, call
		dec	(ix+1Fh)
		jr	z, loc_1088
		dec	(ix+20h)
		call	z, StopTrack		; something to do with 'key off'?
		ld	a, (ix+29h)
		or	a
		jp	z, loc_10D2
		ld	c, (ix+2Ah)
		ld	a, (CurrentChannel)
		cp	6			; is this chanel below 6 (FM)?
		jr	c, loc_1082		; if yes, branch
		ld	c, (ix+41h)

loc_1082:					; CODE XREF: UpdateBGMChannel+3Aj
		ld	a, c
		call	u_UpdateFMVolume
		jr	loc_10D2
; ---------------------------------------------------------------------------

loc_1088:					; CODE XREF: UpdateBGMChannel+23j
						; UpdateBGMChannel+57j
		ld	a, (ix+1Fh)
		or	a
		jr	nz, loc_10D2
		call	RunPattern
		cp	0FFh			; is this pattern finished?
		jr	nz, loc_10CF		; if not, branch

loc_1095:					; CODE XREF: UpdateBGMChannel+8Aj
		call	RunBGMTrack
		cp	0FFh			; has end of track flag	been met?
		jr	nz, loc_1088		; if not, branch
		bit	7, (ix+1Eh)
		call	nz, StopTrack		; something to do with 'key off'?
		ld	a, (CurrentChannel)
		cp	6			; is this channel below	6 (FM)?
		ld	a, 0
		jr	c, loc_10B2		; if yes, branch
		ld	(ix+41h), a
		ld	(ix+3Ch), a

loc_10B2:					; CODE XREF: UpdateBGMChannel+67j
		call	u_UpdateFMVolume
		call	MarkTrackStop
		ld	a, (BGM_LoopFlag)	; load loop flag
		or	a			; test it
		jr	z, loc_10D2		; if it's not set, branch
		ld	l, (ix+3)
		ld	h, (ix+4)		; load track restart position
		ld	(ix+1),	l
		ld	(ix+2),	h		; save it to track's current position
		call	SetBGMChannelPlaying
		jr	loc_1095
; ---------------------------------------------------------------------------

loc_10CF:					; CODE XREF: UpdateBGMChannel+50j
		call	u_PlayNote

loc_10D2:					; CODE XREF: UpdateBGMChannel+2Fj
						; UpdateBGMChannel+43j	...
		pop	bc
		pop	de
		pop	hl
		pop	af
		ret
; End of function UpdateBGMChannel


; =============== S U B	R O U T	I N E =======================================


sub_10D7:					; CODE XREF: sub_B92+6p
		push	af
		push	hl
		push	de
		push	bc
		and	0Fh
		ld	(CurrentChannel), a
		ld	a, (ix+23h)
		and	7Fh
		call	nz, u_Modulation
		ld	a, (ix+29h)		; load volume modifier
		or	a			; test it
		call	nz, u_VolumeEffect	; if it's not zero, call
		dec	(ix+1Fh)
		jr	z, loc_1115
		dec	(ix+20h)
		call	z, StopTrack		; something to do with 'key off'?
		ld	a, (ix+29h)		; load volume modifier
		or	a			; is volume modifier zero?
		jp	z, loc_11A0		; if yes, branch
		ld	c, (ix+2Ah)
		ld	a, (CurrentChannel)
		cp	6			; is this channel below	6 (FM)?
		jr	c, loc_110E		; if yes, branch
		ld	c, (ix+41h)

loc_110E:					; CODE XREF: sub_10D7+32j
		ld	a, c
		call	u_UpdateFMVolume
		jp	loc_11A0
; ---------------------------------------------------------------------------

loc_1115:					; CODE XREF: sub_10D7+1Bj
		call	RunPattern
		cp	0FFh
		jp	nz, loc_119D
		ld	a, (CurrentChannel)
		cp	8
		jr	nz, loc_112A
		xor	a
		ld	(SFX_ChannelsPlaying+1), a
		jr	loc_1139
; ---------------------------------------------------------------------------

loc_112A:					; CODE XREF: sub_10D7+4Bj
		inc	a
		ld	b, a
		ld	c, 7Fh

loc_112E:					; CODE XREF: sub_10D7+59j
		rlc	c
		djnz	loc_112E
		ld	a, (SFX_ChannelsPlaying)
		and	c
		ld	(SFX_ChannelsPlaying), a

loc_1139:					; CODE XREF: sub_10D7+51j
		ld	a, (CurrentChannel)
		ld	b, a
		ld	de, 54h			; de = Channel size
		ld	hl, FM1_BGM_Struct
		or	a			; is this the first channel?
		jr	z, ChannelFound		; if yes, branch

FindChannel:					; CODE XREF: sub_10D7+70j
		add	hl, de			; switch to next channel struct
		djnz	FindChannel		; do until channel found

ChannelFound:					; CODE XREF: sub_10D7+6Dj
		push	hl
		call	StopTrack		; something to do with 'key off'?
		xor	a			; mute channel
		ld	(ix+3Ch), a
		call	u_UpdateFMVolume
		ld	a, (ix+1Ch)
		or	a
		call	nz, FlagF2
		ld	(ix+0),	0
		pop	hl
		push	ix
		push	hl
		pop	ix
		xor	a
		ld	(SFX_Playing), a
		ld	(ix+0),	0
		ld	de, (word_198A)
		ld	(u_ChanNum), de
		ld	c, (ix+1Dh)
		call	LoadInstrument		; Input:
						; c = Instrument Number
		call	loc_984
		ld	a, (ix+1Ch)
		or	a
		call	nz, FlagF3
		ld	a, (ix+2Bh)
		and	1
		call	nz, sub_13F5
		ld	de, 0FFFFh
		ld	(u_ChanNum), de
		pop	ix
		ld	a, 0FFh
		ld	(SFX_Playing), a
		jr	loc_11A0
; ---------------------------------------------------------------------------

loc_119D:					; CODE XREF: sub_10D7+43j
		call	u_PlayNote

loc_11A0:					; CODE XREF: sub_10D7+27j
						; sub_10D7+3Bj	...
		pop	bc
		pop	de
		pop	hl
		pop	af
		ret
; End of function sub_10D7


; =============== S U B	R O U T	I N E =======================================


u_PlayNote:					; CODE XREF: UpdateBGMChannel:loc_10CFp
						; sub_10D7:loc_119Dp
		push	hl
		push	bc
		push	de
		push	de
		ld	b, (ix+25h)
		call	sub_123E
		ld	b, a			; b = Note
		ld	a, (BGM_Pitch)
		call	sub_123E
		call	sub_8D7
		call	sub_95D
		ld	b, c
		ld	a, (SFX_Playing)
		or	a
		jr	z, loc_11CB
		ld	a, (u_OffsetByte2)
		call	sub_124A
		jr	loc_11EE
; ---------------------------------------------------------------------------

loc_11CB:					; CODE XREF: u_PlayNote+1Cj
		ld	a, (u_OffsetByte)
		call	sub_124A
		ld	b, a
		ld	a, (BGM_Volume)
		call	sub_124A
		ld	b, a
		ld	hl, 4
		ld	de, (Offset_BGM)
		add	hl, de
		ld	a, (hl)
		inc	hl
		ld	h, (hl)
		ld	l, a
		add	hl, de
		ld	a, (CurrentChannel)
		ld	e, a
		ld	d, 0
		add	hl, de
		ld	a, (hl)

loc_11EE:					; CODE XREF: u_PlayNote+24j
		call	sub_124A
		ld	b, (ix+26h)
		call	sub_1268
		call	sub_1219
		pop	de
		ld	a, d
		or	a
		jr	z, loc_120C
		ld	a, (ix+20h)		; ? load unk counter
		neg
		jp	m, loc_120F
		call	u_FM_PlayNote
		jr	loc_120F
; ---------------------------------------------------------------------------

loc_120C:					; CODE XREF: u_PlayNote+58j
		call	StopTrack		; something to do with 'key off'?

loc_120F:					; CODE XREF: u_PlayNote+5Fj
						; u_PlayNote+65j
		ld	(ix+1Fh), e
		ld	(ix+20h), d
		pop	de
		pop	bc
		pop	hl
		ret
; End of function u_PlayNote


; =============== S U B	R O U T	I N E =======================================


sub_1219:					; CODE XREF: u_PlayNote+52p
		push	af
		ld	a, (CurrentChannel)
		cp	6
		jr	c, loc_123A
		pop	af
		ld	(ix+3Eh), a
		ld	b, a
		sub	(ix+36h)
		jr	nc, loc_122C
		xor	a

loc_122C:					; CODE XREF: sub_1219+10j
		ld	(ix+3Fh), a
		ld	a, b
		sub	(ix+39h)
		jr	nc, loc_1236
		xor	a

loc_1236:					; CODE XREF: sub_1219+1Aj
		ld	(ix+40h), a
		ret
; ---------------------------------------------------------------------------

loc_123A:					; CODE XREF: sub_1219+6j
		pop	af
		jp	sub_8AF
; End of function sub_1219


; =============== S U B	R O U T	I N E =======================================


sub_123E:					; CODE XREF: u_PlayNote+7p
						; u_PlayNote+Ep
		add	a, b
		jr	nc, loc_1244
		add	a, 60h
		ret
; ---------------------------------------------------------------------------

loc_1244:					; CODE XREF: sub_123E+1j
		cp	60h
		ret	c
		sub	60h
		ret
; End of function sub_123E


; =============== S U B	R O U T	I N E =======================================


sub_124A:					; CODE XREF: u_PlayNote+21p
						; u_PlayNote+29p ...
		push	bc
		sub	63h ; 'c'
		neg
		push	af
		ld	a, b
		sub	63h ; 'c'
		neg
		pop	bc
		add	a, b
		jr	nc, loc_125C
		xor	a
		jr	loc_1262
; ---------------------------------------------------------------------------

loc_125C:					; CODE XREF: sub_124A+Dj
		cp	64h ; 'd'
		jr	c, loc_1262
		ld	a, 63h ; 'c'

loc_1262:					; CODE XREF: sub_124A+10j
						; sub_124A+14j
		sub	63h ; 'c'
		neg
		pop	bc
		ret
; End of function sub_124A


; =============== S U B	R O U T	I N E =======================================


sub_1268:					; CODE XREF: u_PlayNote+4Fp
		add	a, b
		jp	p, loc_126E
		xor	a
		ret
; ---------------------------------------------------------------------------

loc_126E:					; CODE XREF: sub_1268+1j
		cp	64h ; 'd'
		ret	c
		ld	a, 63h ; 'c'
		ret
; End of function sub_1268


; =============== S U B	R O U T	I N E =======================================

; something to do about	volume fading out

u_VolumeEffect:					; CODE XREF: UpdateBGMChannel+1Dp
						; sub_10D7+15p
		dec	(ix+28h)		; decrease timer
		ret	nz			; if ticks remains, branch
		ld	a, (ix+29h)		; load volume modifier
		dec	a			; decrease it
		jp	p, loc_1281		; if positive, branch
		inc	a			; otherwise, make it hesitating	over 0
		inc	a			; ''

loc_1281:					; CODE XREF: u_VolumeEffect+8j
		ld	(ix+29h), a		; set volume modifier
		ld	a, (ix+27h)
		ld	(ix+28h), a		; reload counter value
		ret
; End of function u_VolumeEffect


; =============== S U B	R O U T	I N E =======================================

; a = track byte

CoordFlag:					; CODE XREF: LoadTrackByte+Ap
		inc	hl
		ld	c, (hl)			; c = argument
		sub	0E0h			; subtract flags base from it
		ld	hl, CoordFlagsTbl	; load coordinate flags	jump table
		jr	ExecuteCoordFlag
; End of function CoordFlag


; =============== S U B	R O U T	I N E =======================================

; a = track byte

CoordFlag_NoArg:				; CODE XREF: LoadTrackByte+17p
		sub	0F0h			; subtract flags base from track byte
		ld	hl, CoordFlagsTbl2

ExecuteCoordFlag:				; CODE XREF: CoordFlag+7j
		add	a, a
		ld	e, a
		ld	d, 0
		add	hl, de
		ld	e, (hl)
		inc	hl
		ld	d, (hl)
		ex	de, hl
		jp	(hl)
; End of function CoordFlag_NoArg

; ---------------------------------------------------------------------------
CoordFlagsTbl:	dw FlagE0_LoadInstrument	; DATA XREF: CoordFlag+4o
		dw FlagE1_SetPan
		dw FlagE2_u_PSGEffect
		dw FlagE3_u_VibratoEffect
		dw FlagE4
		dw FlagE5
		dw FlagE6
		dw FlagE7
		dw FlagE8
		dw FlagE9
		dw FlagEA
		dw FlagEB_u_VolumeEffect
		dw FlagEC_SetRepeat
		dw FlagED
CoordFlagsTbl2:	dw FlagF0			; DATA XREF: CoordFlag_NoArg+2o
		dw FlagF1
		dw FlagF2
		dw FlagF3
		dw FlagF4
		dw FlagF5
		dw FlagF6
		dw FlagF7

; =============== S U B	R O U T	I N E =======================================


FlagE0_LoadInstrument:				; DATA XREF: ROM:CoordFlagsTblo
		ld	(ix+1Dh), c		; save instrument in 1Dh
		jp	LoadInstrument		; Input:
; End of function FlagE0_LoadInstrument		; c = Instrument Number


; =============== S U B	R O U T	I N E =======================================


FlagE1_SetPan:					; DATA XREF: ROM:CoordFlagsTblo
		ld	a, c			; a = Argument
		ld	e, 0C0h			; panLR
		or	a
		jr	z, SetChannelPan	; if argument zero, branch
		jp	m, SetPanR		; if argument negative,	branch
		ld	e, 80h			; panL
		jr	SetChannelPan
; ---------------------------------------------------------------------------

SetPanR:					; CODE XREF: FlagE1_SetPan+6j
		ld	e, 40h			; panR

SetChannelPan:					; CODE XREF: FlagE1_SetPan+4j
						; FlagE1_SetPan+Bj
		ld	a, (ix+2Ch)
		and	3Fh
		or	e
		ld	(ix+2Ch), a
		jp	SetFM_Pan_AMS_FMS
; End of function FlagE1_SetPan

; ---------------------------------------------------------------------------

FlagEC_SetRepeat:				; DATA XREF: ROM:CoordFlagsTblo
		ld	a, (ix+0Fh)		; load current stack level
		cp	3			; is level 3?
		ret	z			; if yes, return to avoid stack	overflow
		inc	a			; increase level
		ld	(ix+0Fh), a		; save it
		ld	e, (ix+5)
		ld	d, (ix+6)		; de = Current position	in pattern
		ld	l, (ix+7)
		ld	h, (ix+8)		; hl = Stack offset
		ld	(hl), c			; push repeat count to the stack
		inc	hl
		ld	(hl), e			; push repeat offset
		inc	hl
		ld	(hl), d
		inc	hl
		ld	(ix+7),	l		; save new stack offset
		ld	(ix+8),	h
		ret

; =============== S U B	R O U T	I N E =======================================


RepeatTrack:					; CODE XREF: RunPattern+13p
		ld	a, (ix+0Fh)		; load stack level
		or	a			; test it
		ret	z			; if stack's empty, return
		ld	l, (ix+7)
		ld	h, (ix+8)		; hl = Channel stack pointer
		dec	hl
		ld	d, (hl)			; de = Pattern offset
		dec	hl
		ld	e, (hl)
		dec	hl
		dec	(hl)			; decrease repeat counter
		jr	z, RepeatOver		; if repeat count's over, branch
		inc	de
		inc	de
		ld	(ix+5),	e		; otherwise, play pattern in stack once	again
		ld	(ix+6),	d
		xor	a			; Carry=0
		ret
; ---------------------------------------------------------------------------

RepeatOver:					; CODE XREF: RepeatTrack+11j
		ld	(ix+7),	l		; save new stack pointer
		ld	(ix+8),	h
		dec	(ix+0Fh)		; decrease stack level
		scf				; Carry=1
		ret
; End of function RepeatTrack


; =============== S U B	R O U T	I N E =======================================


SetTrackRestartPos:				; CODE XREF: RunBGMTrack+15p
		ld	l, (ix+1)
		ld	h, (ix+2)		; load current position	in track
		inc	hl			; increase it
		ld	(ix+3),	l
		ld	(ix+4),	h		; save it as new restart position
		ret
; End of function SetTrackRestartPos

; ---------------------------------------------------------------------------

FlagE6:						; DATA XREF: ROM:CoordFlagsTblo
		ld	a, c
		ld	(byte_A), a
		ret
; ---------------------------------------------------------------------------

FlagE7:						; DATA XREF: ROM:CoordFlagsTblo
		ld	a, (byte_A)
		add	a, c
		ld	(byte_A), a
		ret
; ---------------------------------------------------------------------------

FlagE8:						; DATA XREF: ROM:CoordFlagsTblo
		xor	a
		cp	c
		jr	z, loc_136B
		ld	a, (ix+25h)
		add	a, c
		jp	p, loc_1365
		add	a, 60h
		jr	loc_136B
; ---------------------------------------------------------------------------

loc_1365:					; CODE XREF: ROM:135Ej
		cp	60h
		jr	c, loc_136B
		sub	60h

loc_136B:					; CODE XREF: ROM:1358j
						; ROM:1363j ...
		ld	(ix+25h), a
		ret
; ---------------------------------------------------------------------------

FlagE9:						; DATA XREF: ROM:CoordFlagsTblo
		xor	a
		cp	c
		jr	z, loc_1377
		ld	a, (ix+26h)
		add	a, c

loc_1377:					; CODE XREF: ROM:1371j
		ld	(ix+26h), a
		ld	a, (ix+27h)
		or	a
		ret	z
		ld	(ix+28h), a
		xor	a
		cp	c
		jr	z, loc_138A
		ld	a, (ix+29h)
		add	a, c

loc_138A:					; CODE XREF: ROM:1384j
		ld	(ix+29h), a
		ret
; ---------------------------------------------------------------------------

FlagEA:						; DATA XREF: ROM:CoordFlagsTblo
		xor	a
		cp	c
		jr	z, loc_1396
		ld	a, (byte_15)
		add	a, c

loc_1396:					; CODE XREF: ROM:1390j
		ld	(byte_15), a
		ld	c, a
		ld	a, (BGM_Tempo)
		add	a, c
		jp	SetTimerB
; ---------------------------------------------------------------------------
		ret				; unused/overwritten code
; ---------------------------------------------------------------------------

FlagED:						; DATA XREF: ROM:CoordFlagsTblo
		ld	(ix+27h), c
		ret
; ---------------------------------------------------------------------------

FlagEB_u_VolumeEffect:				; DATA XREF: ROM:CoordFlagsTblo
		ld	(ix+22h), c
		ret

; =============== S U B	R O U T	I N E =======================================


FlagE2_u_PSGEffect:				; DATA XREF: ROM:CoordFlagsTblo

; FUNCTION CHUNK AT 0683 SIZE 00000020 BYTES

		ld	a, c
		and	0Fh
		jp	loc_683
; End of function FlagE2_u_PSGEffect


; =============== S U B	R O U T	I N E =======================================


FlagF3:						; CODE XREF: ROM:0D95p
						; sub_10D7+ABp
						; DATA XREF: ...
		ld	(ix+1Ch), 0FFh
		ret
; End of function FlagF3


; =============== S U B	R O U T	I N E =======================================


FlagF2:						; CODE XREF: LoadSFX+8Ep
						; ROM:0D6Dp ...
		ld	(ix+1Ch), 0
		ret
; End of function FlagF2


; =============== S U B	R O U T	I N E =======================================


FlagE3_u_VibratoEffect:				; DATA XREF: ROM:CoordFlagsTblo
		ld	a, c
		and	7Fh
		ld	c, a
		ld	a, (ix+23h)
		and	80h
		or	c
		ld	(ix+23h), a
		ret
; End of function FlagE3_u_VibratoEffect


; =============== S U B	R O U T	I N E =======================================


FlagF4:						; DATA XREF: ROM:CoordFlagsTbl2o
		res	7, (ix+23h)
		res	7, (ix+2Bh)
		ret
; End of function FlagF4


; =============== S U B	R O U T	I N E =======================================


FlagF5:						; DATA XREF: ROM:CoordFlagsTbl2o
		set	7, (ix+23h)
		res	7, (ix+2Bh)
		ret
; End of function FlagF5

; ---------------------------------------------------------------------------

FlagF6:						; DATA XREF: ROM:CoordFlagsTbl2o
		set	7, (ix+2Bh)
		res	6, (ix+2Bh)
		ret
; ---------------------------------------------------------------------------

FlagF7:						; DATA XREF: ROM:CoordFlagsTbl2o
		set	7, (ix+2Bh)
		set	6, (ix+2Bh)
		ret
; ---------------------------------------------------------------------------

FlagE4:						; DATA XREF: ROM:CoordFlagsTblo
		ld	(ix+31h), c
		ret
; ---------------------------------------------------------------------------

FlagF1:						; DATA XREF: ROM:CoordFlagsTbl2o
		ld	a, (SFX_Playing)
		or	a
		ret	nz

; =============== S U B	R O U T	I N E =======================================


sub_13F5:					; CODE XREF: ROM:0D9Dp
						; sub_10D7+B3p
		ld	a, (CurrentChannel)
		cp	6
		ret	nc
		set	0, (ix+2Bh)
		ld	c, a
		ld	a, (u_ChanNum)
		cp	c
		ret	c
		ret	z
		ld	a, c
		ld	(u_ChanNum), a
		jp	loc_668
; End of function sub_13F5

; ---------------------------------------------------------------------------

FlagF0:						; DATA XREF: ROM:CoordFlagsTbl2o
		ld	a, (SFX_Playing)
		or	a
		ret	nz

; =============== S U B	R O U T	I N E =======================================


sub_1412:					; CODE XREF: LoadSFX+95p
		ld	a, (CurrentChannel)	; load current channel
		cp	6			; is this channel 6 and	above (PSG)?
		ret	nc			; if yes, return
		res	0, (ix+2Bh)
		ld	c, a
		ld	a, (u_ChanNum)
		cp	c
		ret	nz
		ld	a, 0FFh
		ld	(u_ChanNum), a
		jp	SetFM_Pan_AMS_FMS
; End of function sub_1412

; ---------------------------------------------------------------------------

FlagE5:						; DATA XREF: ROM:CoordFlagsTblo
		ld	(ix+24h), c
		ld	a, c
		or	a
		jr	z, loc_143A
		inc	c
		ld	(ix+1Fh), c
		ld	(ix+20h), 1
		ret
; ---------------------------------------------------------------------------

loc_143A:					; CODE XREF: ROM:142Fj
		push	ix
		ld	ix, FM1_BGM_Struct
		ld	b, 9

loc_1442:					; CODE XREF: ROM:1470j
		ld	l, (ix+1)
		ld	h, (ix+2)		; hl = Current position	in track
		ld	a, (hl)			; load track's current byte
		cp	0FFh			; is this flag 0FFh (end of track)?
		jr	z, loc_146B		; if yes, branch
		ld	a, (ix+24h)
		or	a
		jr	z, loc_146B
		ld	l, (ix+5)		; de = Current position	in pattern
		ld	h, (ix+6)

loc_1459:					; CODE XREF: ROM:145Fj
		ld	a, (hl)			; load pattern's byte
		cp	0FEh			; is it	0FEh or	0FFh?
		jr	nc, loc_1461		; if yes, branch
		inc	hl			; next byte
		jr	loc_1459		; repeat until found
; ---------------------------------------------------------------------------

loc_1461:					; CODE XREF: ROM:145Cj
		ld	(ix+5),	l		; set pattern's position to where flag 0FEh or 0FFh was found
		ld	(ix+6),	h
		ld	(ix+24h), 0

loc_146B:					; CODE XREF: ROM:144Bj
						; ROM:1451j
		ld	de, 54h			; de = Channel size
		add	ix, de			; next channel
		djnz	loc_1442
		pop	ix
		ret

; =============== S U B	R O U T	I N E =======================================


sub_1475:					; CODE XREF: u_PSG_Update+5p
		push	af
		push	de
		push	bc
		push	hl
		ld	hl, 0Fh
		and	0Fh
		ld	b, (hl)
		ld	(hl), a
		push	bc
		ld	a, (ix+3Ch)
		and	0C0h
		jr	z, loc_14AE
		ld	(ix+3Dh), 1
		rlca
		jr	nc, loc_14AA
		ld	a, (ix+3Fh)
		cp	(ix+3Eh)
		jr	nz, loc_149D
		ld	(ix+3Ch), 10h
		jr	loc_14A1
; ---------------------------------------------------------------------------

loc_149D:					; CODE XREF: sub_1475+20j
		ld	(ix+3Ch), 20h

loc_14A1:					; CODE XREF: sub_1475+26j
		ld	(ix+41h), a
		call	sub_8AF
		jp	loc_152D
; ---------------------------------------------------------------------------

loc_14AA:					; CODE XREF: sub_1475+18j
		ld	(ix+3Ch), 4

loc_14AE:					; CODE XREF: sub_1475+11j
		dec	(ix+3Dh)
		jp	nz, loc_1535
		ld	a, (ix+3Ch)
		rlca
		rlca
		rlca
		jr	nc, loc_14D6
		ld	a, (ix+41h)
		add	a, (ix+37h)
		cp	(ix+3Eh)
		jr	c, loc_14CE
		ld	(ix+3Ch), 10h
		ld	a, (ix+3Eh)

loc_14CE:					; CODE XREF: sub_1475+50j
		ld	(ix+41h), a
		call	sub_8AF
		jr	loc_152D
; ---------------------------------------------------------------------------

loc_14D6:					; CODE XREF: sub_1475+45j
		rlca
		jr	nc, loc_14FB
		ld	a, (ix+41h)
		or	a
		jr	z, loc_152D
		sub	(ix+38h)
		jr	nc, loc_14E5
		xor	a

loc_14E5:					; CODE XREF: sub_1475+6Dj
		cp	(ix+40h)
		jr	z, loc_14EC
		jr	nc, loc_14F3

loc_14EC:					; CODE XREF: sub_1475+73j
		ld	(ix+3Ch), 8
		ld	a, (ix+40h)

loc_14F3:					; CODE XREF: sub_1475+75j
		ld	(ix+41h), a
		call	sub_8AF
		jr	loc_152D
; ---------------------------------------------------------------------------

loc_14FB:					; CODE XREF: sub_1475+62j
		rlca
		jr	nc, loc_1512
		ld	a, (ix+41h)
		or	a
		jr	z, loc_152D
		sub	(ix+3Ah)
		jr	nc, loc_150A
		xor	a

loc_150A:					; CODE XREF: sub_1475+92j
		ld	(ix+41h), a
		call	sub_8AF
		jr	loc_152D
; ---------------------------------------------------------------------------

loc_1512:					; CODE XREF: sub_1475+87j
		rlca
		jr	nc, loc_152D
		ld	a, (ix+41h)
		or	a
		jr	nz, loc_1521
		ld	(ix+3Ch), 0
		jr	loc_152D
; ---------------------------------------------------------------------------

loc_1521:					; CODE XREF: sub_1475+A4j
		sub	(ix+3Bh)
		jr	nc, loc_1527
		xor	a

loc_1527:					; CODE XREF: sub_1475+AFj
		ld	(ix+41h), a
		call	sub_8AF

loc_152D:					; CODE XREF: sub_1475+32j
						; sub_1475+5Fj	...
		ld	a, 64h
		sub	(ix+35h)
		ld	(ix+3Dh), a

loc_1535:					; CODE XREF: sub_1475+3Cj
		pop	af
		ld	(CurrentChannel), a
		pop	hl
		pop	bc
		pop	de
		pop	af
		ret
; End of function sub_1475


; =============== S U B	R O U T	I N E =======================================


sub_153E:					; CODE XREF: u_LFO_Proc:loc_BEFp
		bit	0, (ix+2Bh)
		ret	z
		ld	(CurrentChannel), a
		push	af
		push	bc
		push	hl
		push	de
		ld	bc, (word_29)
		ld	l, (ix+43h)
		ld	h, (ix+44h)
		or	a
		sbc	hl, bc
		jr	z, loc_1574
		ld	(ix+43h), c
		ld	(ix+44h), b
		rlc	b
		rlc	b
		rlc	b
		rlc	b
		ld	a, (ix+2Ch)		; load panning,	AMS/FMS	setting
		and	0C0h			; clear	AMS/FMS	bits
		or	b
		or	c
		ld	(ix+2Ch), a		; save settings
		call	SetFM_Pan_AMS_FMS

loc_1574:					; CODE XREF: sub_153E+19j
		pop	de
		pop	hl
		pop	bc
		pop	af
		ret
; End of function sub_153E


; =============== S U B	R O U T	I N E =======================================

; something to do with LFO

u_LFO_Proc:					; CODE XREF: UpdateModulation+28p

; FUNCTION CHUNK AT 0BE1 SIZE 0000001B BYTES

		ld	a, (u_LFO_Byte)
		ld	c, a
		and	0C0h
		jr	z, loc_15A1
		ld	a, c
		bit	7, a
		jr	z, loc_1591
		and	7Fh
		ld	c, a
		and	7
		ld	h, 22h
		call	Write_FM_I		; YM ->	Set LFO
		ld	a, c

loc_1591:					; CODE XREF: u_LFO_Proc+Bj
		bit	6, a
		jr	z, loc_15A1
		and	0BFh
		ld	c, a
		and	7
		or	8
		ld	h, 22h
		call	Write_FM_I		; YM ->	Set LFO

loc_15A1:					; CODE XREF: u_LFO_Proc+6j
						; u_LFO_Proc+1Aj
		ld	a, c
		ld	(u_LFO_Byte), a
		jp	loc_BE1
; End of function u_LFO_Proc

; ---------------------------------------------------------------------------
FM_Frequencies:	dw 284h, 2AAh, 2D3h, 2FEh, 32Bh, 35Bh, 38Eh, 3C4h, 3FEh
						; DATA XREF: sub_95D+BBo
		dw 43Bh, 47Bh, 4BFh
FM_PortamentoFreq:db 0,	1, 2, 4, 5, 6, 7, 8, 0Ah, 0Bh, 0Ch, 0Dh, 0Eh, 10h
						; DATA XREF: sub_95D+CFo
		db 11h,	12h, 13h, 14h, 16h, 17h, 18h, 19h, 1Ah,	1Ch, 1Dh
		db 1Eh,	1Fh, 20h, 21h, 23h, 24h, 25h
		db 0, 1, 3, 4, 5, 6, 8,	9, 0Ah,	0Bh, 0Dh, 0Eh, 0Fh, 10h
		db 12h,	13h, 14h, 16h, 17h, 18h, 19h, 1Bh, 1Ch,	1Dh, 1Eh
		db 20h,	21h, 22h, 23h, 25h, 26h, 27h
		db 0, 1, 3, 4, 5, 7, 8,	9, 0Bh,	0Ch, 0Dh, 0Fh, 10h, 11h
		db 13h,	14h, 15h, 17h, 18h, 1Ah, 1Bh, 1Ch, 1Eh,	1Fh, 20h
		db 22h,	23h, 24h, 26h, 27h, 28h, 2Ah
		db 0, 1, 3, 4, 6, 7, 9,	0Ah, 0Bh, 0Dh, 0Eh, 10h, 11h, 12h
		db 14h,	15h, 17h, 18h, 1Ah, 1Bh, 1Ch, 1Eh, 1Fh,	21h, 22h
		db 24h,	25h, 26h, 28h, 29h, 2Bh, 2Ch
		db 0, 2, 3, 5, 6, 8, 9,	0Bh, 0Ch, 0Eh, 0Fh, 11h, 12h, 14h
		db 15h,	17h, 18h, 1Ah, 1Bh, 1Dh, 1Eh, 20h, 21h,	23h, 24h
		db 26h,	27h, 29h, 2Ah, 2Ch, 2Dh, 2Fh
		db 0, 2, 3, 5, 6, 8, 0Ah, 0Bh, 0Dh, 0Eh, 10h, 12h, 13h
		db 15h,	16h, 18h, 1Ah, 1Bh, 1Dh, 1Eh, 20h, 22h,	23h, 25h
		db 26h,	28h, 2Ah, 2Bh, 2Dh, 2Eh, 30h, 31h
		db 0, 2, 3, 5, 7, 8, 0Ah, 0Ch, 0Eh, 0Fh, 11h, 13h, 14h
		db 16h,	18h, 19h, 1Bh, 1Dh, 1Eh, 20h, 22h, 24h,	25h, 27h
		db 29h,	2Ah, 2Ch, 2Eh, 2Fh, 30h, 33h, 34h
		db 0, 2, 4, 5, 7, 9, 0Bh, 0Dh, 0Eh, 10h, 12h, 14h, 16h
		db 17h,	19h, 1Bh, 1Dh, 1Eh, 20h, 22h, 24h, 26h,	27h, 29h
		db 2Bh,	2Dh, 2Fh, 30h, 32h, 34h, 36h, 38h
		db 0, 2, 4, 6, 8, 9, 0Bh, 0Dh, 0Fh, 11h, 13h, 15h, 17h
		db 19h,	1Bh, 1Ch, 1Eh, 20h, 22h, 24h, 26h, 28h,	2Ah, 2Ch
		db 2Eh,	2Fh, 31h, 33h, 35h, 37h, 39h, 3Bh
		db 0, 2, 4, 6, 8, 0Ah, 0Ch, 0Eh, 10h, 12h, 14h,	16h, 18h
		db 1Ah,	1Ch, 1Eh, 20h, 22h, 24h, 26h, 28h, 2Ah,	2Ch, 2Eh
		db 30h,	32h, 34h, 36h, 38h, 3Ah, 3Ch, 3Eh
		db 0, 2, 4, 6, 9, 0Bh, 0Dh, 0Fh, 11h, 13h, 15h,	17h, 1Ah
		db 1Ch,	1Eh, 20h, 22h, 24h, 26h, 28h, 2Bh, 2Dh,	2Fh, 31h
		db 33h,	35h, 37h, 3Ah, 3Ch, 3Eh, 40h, 42h
		db 0, 2, 5, 7, 9, 0Bh, 0Eh, 10h, 12h, 14h, 17h,	19h, 1Bh
		db 1Dh,	20h, 22h, 24h, 26h, 29h, 2Bh, 2Dh, 2Fh,	32h, 34h
		db 36h,	38h, 3Bh, 3Dh, 3Fh, 41h, 44h, 46h
PSG_Frequencies:dw 357h, 327h, 2FAh, 2CFh, 2A7h, 281h, 25Dh, 23Bh, 21Bh
						; DATA XREF: sub_95D+50o
		dw 1FCh, 1E0h, 1C5h
PSG_PortamentoFreq:db 0, 2, 3, 5, 6, 8,	0Ah, 0Bh, 0Dh, 0Eh, 10h, 11h, 13h
						; DATA XREF: sub_95D+70o
		db 14h,	16h, 17h, 19h, 1Bh, 1Ch, 1Eh, 1Fh, 21h,	22h, 23h
		db 25h,	26h, 28h, 29h, 2Bh, 2Ch, 2Eh, 2Fh
		db 0, 2, 3, 5, 6, 7, 9,	0Ah, 0Ch, 0Dh, 0Fh, 10h, 12h, 13h
		db 15h,	16h, 17h, 19h, 1Ah, 1Ch, 1Dh, 1Fh, 20h,	21h, 23h
		db 24h,	26h, 27h, 28h, 2Ah, 2Bh, 2Ch
		db 0, 1, 3, 4, 6, 7, 8,	0Ah, 0Bh, 0Dh, 0Eh, 0Fh, 11h, 12h
		db 14h,	15h, 16h, 18h, 19h, 1Ah, 1Ch, 1Dh, 1Eh,	20h, 21h
		db 22h,	24h, 25h, 26h, 27h, 29h, 2Ah
		db 0, 1, 3, 4, 5, 7, 8,	0Ah, 0Bh, 0Ch, 0Dh, 0Fh, 10h, 11h
		db 12h,	14h, 15h, 16h, 17h, 19h, 1Ah, 1Bh, 1Ch,	1Eh, 1Fh
		db 20h,	21h, 23h, 24h, 25h, 26h, 27h
		db 0, 1, 3, 4, 5, 6, 8,	9, 0Ah,	0Bh, 0Dh, 0Eh, 0Fh, 10h
		db 11h,	13h, 14h, 15h, 16h, 17h, 19h, 1Ah, 1Bh,	1Ch, 1Dh
		db 1Eh,	20h, 21h, 22h, 23h, 24h, 25h
		db 0, 1, 2, 4, 5, 6, 7,	8, 9, 0Bh, 0Ch,	0Dh, 0Eh, 0Fh
		db 10h,	11h, 13h, 14h, 15h, 16h, 17h, 18h, 19h,	1Ah, 1Ch
		db 1Dh,	1Eh, 1Fh, 20h, 21h, 22h, 23h
		db 0, 1, 2, 3, 5, 6, 7,	8, 9, 0Ah, 0Bh,	0Ch, 0Dh, 0Eh
		db 0Fh,	11h, 12h, 13h, 14h, 15h, 16h, 17h, 18h,	19h, 1Ah
		db 1Bh,	1Ch, 1Dh, 1Eh, 1Fh, 20h, 21h
		db 0, 1, 2, 3, 4, 5, 6,	7, 8, 9, 0Bh, 0Ch, 0Dh,	0Eh, 0Fh
		db 10h,	11h, 12h, 13h, 14h, 15h, 16h, 17h, 18h,	19h, 1Ah
		db 1Bh,	1Ch, 1Dh, 1Dh, 1Eh, 1Fh
		db 0, 1, 2, 3, 4, 5, 6,	7, 8, 9, 0Ah, 0Bh, 0Ch,	0Dh, 0Eh
		db 0Fh,	10h, 11h, 12h, 12h, 13h, 14h, 15h, 16h,	17h, 18h
		db 19h,	1Ah, 1Bh, 1Ch, 1Dh, 1Eh
		db 0, 1, 2, 3, 4, 5, 6,	7, 7, 8, 9, 0Ah, 0Bh, 0Ch, 0Dh
		db 0Eh,	0Fh, 10h, 10h, 11h, 12h, 13h, 14h, 15h,	16h, 17h
		db 17h,	18h, 19h, 1Ah, 1Bh, 1Ch
		db 0, 1, 2, 3, 4, 4, 5,	6, 7, 8, 9, 0Ah, 0Ah, 0Bh, 0Ch
		db 0Dh,	0Eh, 0Fh, 10h, 10h, 11h, 12h, 13h, 14h,	15h, 15h
		db 16h,	17h, 18h, 19h, 19h, 1Ah
		db 0, 1, 2, 3, 3, 4, 5,	6, 7, 8, 8, 9, 0Ah, 0Bh, 0Ch, 0Ch
		db 0Dh,	0Eh, 0Fh, 10h, 10h, 11h, 12h, 13h, 13h,	14h, 15h
		db 16h,	17h, 17h, 18h, 19h
; ---------------------------------------------------------------------------

LoadSoundBank:					; DATA XREF: ROM:CommandsTableo
		di
		ld	hl,  Input+1
		call	LoadBank		; (hl) = Bank offset (Big Endian)
		ld	hl, Input
		ld	de, u_MusicBankOffset
		ldi				; transfer 4-byte offset
		ldi				; ''
		ldi				; ''
		ldi				; ''
		xor	a
		ld	(Command), a
		ei
		ret

; =============== S U B	R O U T	I N E =======================================


DoBankSwitch:					; CODE XREF: ROM:017Ep
						; ROM:01F3p
		push	hl
		push	bc
		ld	hl, ROM_Offset2
		call	LoadBank		; (hl) = Bank offset (Big Endian)
		pop	bc
		pop	hl
		ret
; End of function DoBankSwitch


; =============== S U B	R O U T	I N E =======================================

; (hl) = Bank offset (Big Endian)

LoadBank:					; CODE XREF: ROM:0175p
						; ROM:01AAp ...
		ld	c, (hl)			; load offset's high byte
		inc	hl
		ld	a, (hl)			; load offset's low byte
		rlca
		ld	(BankRegister),	a	; set A15
		ld	b, 8
		ld	a, c

LoadBank_Loop:					; CODE XREF: LoadBank+Ej
		ld	(BankRegister),	a	; set address bits A16-A23
		rrca
		djnz	LoadBank_Loop		; repeat for 8 bits
		ret
; End of function LoadBank

; ---------------------------------------------------------------------------
Copyright:	.ascii 'Ver 1.31 92.04.23 (C)T.SZ80'
		db  11h
		db  44h	; D
		db    2
		db  2Bh	; +
		db  59h	; Y
		db  5Dh	; ]
		db  28h	; (
		db    0
		db 0FFh
		db  64h	; d
		db 0F7h	; ÷
		db  38h	; 8
		db 0F9h	; ù
		db  9Ch	; 
		db 0CCh	; Ì
		db 0E5h	; å
		db    1
		db  64h	; d
		db    8
		db  42h	; B
		db  75h	; u
		db  7Fh	; 
		db 0C3h	; Ã
		db  3Ch	; <
		db    0
		db  4Fh	; O
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db 0C3h	; Ã			; it appears that data below is	garbage, although loaded in Z80	RAM
						; the following	bytes seem like	another	Z80 driver's code
		db 0B9h	; ¹
		db    0
		db    0
		db 0F3h	; ó
		db 0EDh	; í
		db  56h	; V
		db  31h	; 1
PCM_Data:	dw 2000h			; DATA XREF: ROM:0060o
						; ROM:007Ao ...
		dw 13Eh
		dw 32h
		db  60h	; `
		db  32h	; 2
		db    0
		db  60h	; `
word_198A:	dw 32h				; DATA XREF: DriverInterrupt+19w
						; DriverInterrupt+2Fr ...
SFX_Playing:	db 60h				; DATA XREF: sub_2D4+6w
						; SetChannelVolume+14r	...
byte_198D:	db 32h				; DATA XREF: sub_2D4+9r
						; sub_306w
Offset_BGM:	dw 6000h			; DATA XREF: ROM:00B0w
						; GetFMInstrPointer+14r ...
Offset_SFX:	dw 32AFh			; DATA XREF: ROM:00B6w
						; GetFMInstrPointer+1Dr ...
FM1_BGM_Struct:	db 0, 60h, 32h,	0, 60h,	32h, 0,	60h, 32h, 0, 60h, 32h
						; DATA XREF: sub_306+7o
						; u_LFO_Proc-994o ...
		db 0, 60h, 21h,	80h, 19h, 11h, 81h, 19h, 1, 6, 6, 36h
		db 0, 0EDh, 0B0h, 21h, 0, 7, 11h, 80h, 0, 22h, 7Fh, 1Fh
		db 0EDh, 53h, 81h, 1Fh,	21h, 80h, 19h, 7Ch, 32h, 36h, 0
		db 7Dh,	32h, 37h, 0, 0AFh, 67h,	6Ch, 22h, 20h, 0, 22h
		db 22h,	0, 36h,	0FFh, 21h, 0, 80h, 22h,	8Eh, 19h, 21h
		db 0, 0F0h, 22h, 90h, 19h, 3Eh,	63h, 32h, 84h, 1Fh, 32h
		db 85h,	1Fh, 0FBh, 21h
FM2_BGM_Struct:	db 0, 0, 22h, 2, 0, 3Ah, 3, 0, 0B7h, 20h, 2, 18h, 0F8h
		db 0AFh, 32h, 3, 0, 18h, 0F2h, 0F3h, 0,	0FBh, 0C9h, 5Ah
		db 38h,	30h, 40h, 0, 40h, 2, 40h, 3, 40h, 5, 40h, 6, 40h
		db 8, 3Fh, 9, 3Fh, 0Bh,	3Fh, 0Ch, 3Eh, 0Eh, 3Eh, 10h, 3Eh
		db 11h,	3Dh, 13h, 3Dh, 14h, 3Ch, 16h, 3Ch, 17h,	3Bh, 18h
		db 3Bh,	1Ah, 3Ah, 1Bh, 39h, 1Dh, 38h, 1Eh, 38h,	20h, 37h
		db 21h,	36h, 22h, 35h, 24h, 34h, 25h, 33h, 26h,	32h, 27h
		db 31h,	29h
FM3_BGM_Struct:	db 30h,	2Ah, 2Fh, 2Bh, 2Eh, 2Ch, 2Dh, 2Dh, 2Ch,	2Eh, 2Bh
		db 2Fh,	2Ah, 30h, 29h, 31h, 27h, 32h, 26h, 33h,	25h, 34h
		db 24h,	35h, 22h, 36h, 21h, 37h, 20h, 38h, 1Eh,	38h, 1Dh
		db 39h,	1Bh, 3Ah, 1Ah, 3Bh, 18h, 3Bh, 17h, 3Ch,	16h, 3Ch
		db 14h,	3Dh, 13h, 3Dh, 11h, 3Eh, 10h, 3Eh, 0Eh,	3Eh, 0Ch
		db 3Fh,	0Bh, 3Fh, 9, 3Fh, 8, 40h, 6, 40h, 5, 40h, 3, 40h
		db 2, 40h, 0, 40h, 0FFh, 40h, 0FEh, 40h, 0FCh, 40h, 0FBh
		db 40h,	0F9h, 40h, 0F8h, 3Fh
FM4_BGM_Struct:	db 0F6h, 3Fh, 0F5h, 3Fh, 0F3h, 3Eh, 0F1h, 3Eh, 0F0h, 3Eh
		db 0EEh, 3Dh, 0EDh, 3Dh, 0EBh, 3Ch, 0EAh, 3Ch, 0E9h, 3Bh
		db 0E7h, 3Bh, 0E6h, 3Ah, 0E4h, 39h, 0E3h, 38h, 0E1h, 38h
		db 0E0h, 37h, 0DFh, 36h, 0DDh, 35h, 0DCh, 34h, 0DBh, 33h
		db 0DAh, 32h, 0D8h, 31h, 0D7h, 30h, 0D6h, 2Fh, 0D5h, 2Eh
		db 0D4h, 2Dh, 0D3h, 2Ch, 0D2h, 2Bh, 0D1h, 2Ah, 0D0h, 29h
		db 0CFh, 27h, 0CEh, 26h, 0CDh, 25h, 0CCh, 24h, 0CBh, 22h
		db 0CAh, 21h, 0C9h, 20h, 0C9h, 1Eh, 0C8h, 1Dh, 0C7h, 1Bh
		db 0C6h, 1Ah, 0C6h, 18h
FM5_BGM_Struct:	db 0C5h, 17h, 0C5h, 16h, 0C4h, 14h, 0C4h, 13h, 0C3h, 11h
		db 0C3h, 10h, 0C3h, 0Eh, 0C2h, 0Ch, 0C2h, 0Bh, 0C2h, 9
		db 0C1h, 8, 0C1h, 6, 0C1h, 5, 0C1h, 3, 0C1h, 2,	0C1h, 0
		db 0C1h, 0FFh, 0C1h, 0FEh, 0C1h, 0FCh, 0C1h, 0FBh, 0C1h
		db 0F9h, 0C2h, 0F8h, 0C2h, 0F6h, 0C2h, 0F5h, 0C3h, 0F3h
		db 0C3h, 0F1h, 0C3h, 0F0h, 0C4h, 0EEh, 0C4h, 0EDh, 0C5h
		db 0EBh, 0C5h, 0EAh, 0C6h, 0E9h, 0C6h, 0E7h, 0C7h, 0E6h
		db 0C8h, 0E4h, 0C9h, 0E3h, 0C9h, 0E1h, 0CAh, 0E0h, 0CBh
		db 0DFh, 0CCh, 0DDh, 0CDh, 0DCh, 0CEh, 0DBh
FM6_BGM_Struct:	db 0CFh, 0DAh, 0D0h, 0D8h, 0D1h, 0D7h, 0D2h, 0D6h, 0D3h
						; DATA XREF: RestoreFM6_Pan_AMS_FMS+12o
		db 0D5h, 0D4h, 0D4h, 0D5h, 0D3h, 0D6h, 0D2h, 0D7h, 0D1h
		db 0D8h, 0D0h, 0DAh, 0CFh, 0DBh, 0CEh, 0DCh, 0CDh, 0DDh
		db 0CCh, 0DFh, 0CBh, 0E0h, 0CAh, 0E1h, 0C9h, 0E3h, 0C9h
		db 0E4h, 0C8h, 0E6h, 0C7h, 0E7h, 0C6h, 0E9h, 0C6h, 0EAh
		db 0C5h, 0EBh, 0C5h, 0EDh, 0C4h, 0EEh, 0C4h, 0F0h, 0C3h
		db 0F1h, 0C3h, 0F3h, 0C3h, 0F5h, 0C2h, 0F6h, 0C2h, 0F8h
		db 0C2h, 0F9h, 0C1h, 0FBh, 0C1h, 0FCh, 0C1h, 0FEh, 0C1h
		db 0FFh, 0C1h, 0, 0C1h,	2, 0C1h, 3, 0C1h, 5, 0C1h, 6, 0C1h
PSG1_BGM_Struct:db 8, 0C1h, 9, 0C2h, 0Bh, 0C2h,	0Ch, 0C2h, 0Eh,	0C3h, 10h
						; DATA XREF: UpdateModulation+Bo
		db 0C3h, 11h, 0C3h, 13h, 0C4h, 14h, 0C4h, 16h, 0C5h, 17h
		db 0C5h, 18h, 0C6h, 1Ah, 0C6h, 1Bh, 0C7h, 1Dh, 0C8h, 1Eh
		db 0C9h, 20h, 0C9h, 21h, 0CAh, 22h, 0CBh, 24h, 0CCh, 25h
		db 0CDh, 26h, 0CEh, 27h, 0CFh, 29h, 0D0h, 2Ah, 0D1h, 2Bh
		db 0D2h, 2Ch, 0D3h, 2Dh, 0D4h, 2Eh, 0D5h, 2Fh, 0D6h, 30h
		db 0D7h, 31h, 0D8h, 32h, 0DAh, 33h, 0DBh, 34h, 0DCh, 35h
		db 0DDh, 36h, 0DFh, 37h, 0E0h, 38h, 0E1h, 38h, 0E3h, 39h
		db 0E4h, 3Ah, 0E6h
PSG2_BGM_Struct:db 3Bh,	0E7h, 3Bh, 0E9h, 3Ch, 0EAh, 3Ch, 0EBh, 3Dh, 0EDh
		db 3Dh,	0EEh, 3Eh, 0F0h, 3Eh, 0F1h, 3Eh, 0F3h, 3Fh, 0F5h
		db 3Fh,	0F6h, 3Fh, 0F8h, 40h, 0F9h, 40h, 0FBh, 40h, 0FCh
		db 40h,	0FEh, 40h, 0FFh, 40h, 0, 40h, 2, 40h, 3, 40h, 5
		db 40h,	6, 40h,	8, 3Fh,	9, 3Fh,	0Bh, 3Fh, 0Ch, 3Eh, 0Eh
		db 3Eh,	10h, 3Eh, 11h, 3Dh, 13h, 3Dh, 14h, 3Ch,	16h, 3Ch
		db 17h,	3Bh, 18h, 3Bh, 1Ah, 3Ah, 1Bh, 39h, 1Dh,	38h, 1Eh
		db 38h,	20h, 37h, 21h, 36h, 22h, 35h, 24h
PSG3_BGM_Struct:db 34h,	25h, 33h, 26h, 32h, 27h, 31h, 29h, 30h,	2Ah, 2Fh
		db 2Bh,	2Eh, 2Ch, 2Dh, 2Dh, 2Ch, 2Eh, 2Bh, 2Fh,	2Ah, 30h
		db 29h,	31h, 27h, 32h, 26h, 33h, 25h, 34h, 24h,	35h, 22h
		db 36h,	21h, 37h, 20h, 38h, 1Eh, 38h, 1Dh, 39h,	1Bh, 3Ah
		db 1Ah,	3Bh, 18h, 3Bh, 17h, 3Ch, 16h, 3Ch, 14h,	3Dh, 13h
		db 3Dh,	11h, 3Eh, 10h, 3Eh, 0Eh, 3Eh, 0Ch, 3Fh,	0Bh, 3Fh
		db 9, 3Fh, 8, 40h, 6, 40h, 5, 40h, 3, 40h, 2, 40h, 0, 40h
		db 0FFh, 40h, 0FEh, 40h
FM1_SFX_Struct:	db 0FCh, 40h, 0FBh, 40h, 0F9h, 40h, 0F8h, 3Fh, 0F6h, 3Fh
						; DATA XREF: sub_306+Ao
						; DriverInterrupt+24o ...
		db 0F5h, 3Fh, 0F3h, 3Eh, 0F1h, 3Eh, 0F0h, 3Eh, 0EEh, 3Dh
		db 0EDh, 3Dh, 0EBh, 3Ch, 0EAh, 3Ch, 0E9h, 3Bh, 0E7h, 3Bh
		db 0E6h, 3Ah, 0E4h, 39h, 0E3h, 38h, 0E1h, 38h, 0E0h, 37h
		db 0DFh, 36h, 0DDh, 35h, 0DCh, 34h, 0DBh, 33h, 0DAh, 32h
		db 0D8h, 31h, 0D7h, 30h, 0D6h, 2Fh, 0D5h, 2Eh, 0D4h, 2Dh
		db 0D3h, 2Ch, 0D2h, 2Bh, 0D1h, 2Ah, 0D0h, 29h, 0CFh, 27h
		db 0CEh, 26h, 0CDh, 25h, 0CCh, 24h, 0CBh, 22h, 0CAh, 21h
		db 0C9h, 20h, 0C9h, 1Eh
FM2_SFX_Struct:	db 0C8h, 1Dh, 0C7h, 1Bh, 0C6h, 1Ah, 0C6h, 18h, 0C5h, 17h
		db 0C5h, 16h, 0C4h, 14h, 0C4h, 13h, 0C3h, 11h, 0C3h, 10h
		db 0C3h, 0Eh, 0C2h, 0Ch, 0C2h, 0Bh, 0C2h, 9, 0C1h, 8, 0C1h
		db 6, 0C1h, 5, 0C1h, 3,	0C1h, 2, 0C1h, 0, 0C1h,	0FFh, 0C1h
		db 0FEh, 0C1h, 0FCh, 0C1h, 0FBh, 0C1h, 0F9h, 0C2h, 0F8h
		db 0C2h, 0F6h, 0C2h, 0F5h, 0C3h, 0F3h, 0C3h, 0F1h, 0C3h
		db 0F0h, 0C4h, 0EEh, 0C4h, 0EDh, 0C5h, 0EBh, 0C5h, 0EAh
		db 0C6h, 0E9h, 0C6h, 0E7h, 0C7h, 0E6h, 0C8h, 0E4h, 0C9h
		db 0E3h, 0C9h, 0E1h, 0CAh, 0E0h
FM3_SFX_Struct:	db 0CBh, 0DFh, 0CCh, 0DDh, 0CDh, 0DCh, 0CEh, 0DBh, 0CFh
		db 0DAh, 0D0h, 0D8h, 0D1h, 0D7h, 0D2h, 0D6h, 0D3h, 0D5h
		db 0D4h, 0D4h, 0D5h, 0D3h, 0D6h, 0D2h, 0D7h, 0D1h, 0D8h
		db 0D0h, 0DAh, 0CFh, 0DBh, 0CEh, 0DCh, 0CDh, 0DDh, 0CCh
		db 0DFh, 0CBh, 0E0h, 0CAh, 0E1h, 0C9h, 0E3h, 0C9h, 0E4h
		db 0C8h, 0E6h, 0C7h, 0E7h, 0C6h, 0E9h, 0C6h, 0EAh, 0C5h
		db 0EBh, 0C5h, 0EDh, 0C4h, 0EEh, 0C4h, 0F0h, 0C3h, 0F1h
		db 0C3h, 0F3h, 0C3h, 0F5h, 0C2h, 0F6h, 0C2h, 0F8h, 0C2h
		db 0F9h, 0C1h, 0FBh, 0C1h, 0FCh, 0C1h, 0FEh, 0C1h, 0FFh
		db 0C1h, 0, 0C1h
FM4_SFX_Struct:	db 2, 0C1h, 3, 0C1h, 5,	0C1h, 6, 0C1h, 8, 0C1h,	9, 0C2h
		db 0Bh,	0C2h, 0Ch, 0C2h, 0Eh, 0C3h, 10h, 0C3h, 11h, 0C3h
		db 13h,	0C4h, 14h, 0C4h, 16h, 0C5h, 17h, 0C5h, 18h, 0C6h
		db 1Ah,	0C6h, 1Bh, 0C7h, 1Dh, 0C8h, 1Eh, 0C9h, 20h, 0C9h
		db 21h,	0CAh, 22h, 0CBh, 24h, 0CCh, 25h, 0CDh, 26h, 0CEh
		db 27h,	0CFh, 29h, 0D0h, 2Ah, 0D1h, 2Bh, 0D2h, 2Ch, 0D3h
		db 2Dh,	0D4h, 2Eh, 0D5h, 2Fh, 0D6h, 30h, 0D7h, 31h, 0D8h
		db 32h,	0DAh, 33h, 0DBh, 34h, 0DCh, 35h, 0DDh, 36h, 0DFh
		db 37h,	0E0h
FM5_SFX_Struct:	db 38h,	0E1h, 38h, 0E3h, 39h, 0E4h, 3Ah, 0E6h, 3Bh, 0E7h
		db 3Bh,	0E9h, 3Ch, 0EAh, 3Ch, 0EBh, 3Dh, 0EDh, 3Dh, 0EEh
		db 3Eh,	0F0h, 3Eh, 0F1h, 3Eh, 0F3h, 3Fh, 0F5h, 3Fh, 0F6h
		db 3Fh,	0F8h, 40h, 0F9h, 40h, 0FBh, 40h, 0FCh, 40h, 0FEh
		db 40h,	0FFh, 40h, 0, 40h, 1, 40h, 2, 40h, 2, 40h, 3, 40h
		db 4, 40h, 5, 40h, 5, 40h, 6, 40h, 7, 40h, 8, 3Fh, 9, 3Fh
		db 9, 3Fh, 0Ah,	3Fh, 0Bh, 3Fh, 0Ch, 3Fh, 0Ch, 3Fh, 0Dh
		db 3Eh,	0Eh, 3Eh, 0Fh, 3Eh, 10h
FM6_SFX_Struct:	db 3Eh,	10h, 3Eh, 11h, 3Dh, 12h, 3Dh, 13h, 3Dh,	13h, 3Dh
						; DATA XREF: RestoreFM6_Pan_AMS_FMS+7o
		db 14h,	3Dh, 15h, 3Ch, 16h, 3Ch, 16h, 3Ch, 17h,	3Bh, 18h
		db 3Bh,	18h, 3Bh, 19h, 3Bh, 1Ah, 3Ah, 1Bh, 3Ah,	1Bh, 3Ah
		db 1Ch,	39h, 1Dh, 39h, 1Dh, 38h, 1Eh, 38h, 1Fh,	38h, 20h
		db 37h,	20h, 37h, 21h, 36h, 22h, 36h, 22h, 36h,	23h, 35h
		db 24h,	35h, 24h, 34h, 25h, 34h, 25h, 33h, 26h,	33h, 27h
		db 32h,	27h, 32h, 28h, 31h, 29h, 31h, 29h, 30h,	2Ah, 30h
		db 2Ah,	2Fh, 2Bh, 2Fh, 2Ch, 2Eh, 2Ch
PSG1_SFX_Struct:db 2Eh,	2Dh, 2Dh, 2Dh, 2Dh, 2Eh, 2Ch, 2Eh, 2Ch,	2Fh, 2Bh
						; DATA XREF: UpdateModulation+17o
		db 2Fh,	2Ah, 30h, 2Ah, 30h, 29h, 31h, 29h, 31h,	28h, 32h
		db 27h,	32h, 27h, 33h, 26h, 33h, 25h, 34h, 25h,	34h, 24h
		db 35h,	24h, 35h, 23h, 36h, 22h, 36h, 22h, 36h,	21h, 37h
		db 20h,	37h, 20h, 38h, 1Fh, 38h, 1Eh, 38h, 1Dh,	39h, 1Dh
		db 39h,	1Ch, 3Ah, 1Bh, 3Ah, 1Bh, 3Ah, 1Ah, 3Bh,	19h, 3Bh
		db 18h,	3Bh, 18h, 3Bh, 17h, 3Ch, 16h, 3Ch, 16h,	3Ch, 15h
		db 3Dh,	14h, 3Dh, 13h, 3Dh, 13h, 3Dh
PSG2_SFX_Struct:db 12h,	3Dh, 11h, 3Eh, 10h, 3Eh, 10h, 3Eh, 0Fh,	3Eh, 0Eh
		db 3Eh,	0Dh, 3Fh, 0Ch, 3Fh, 0Ch, 3Fh, 0Bh, 3Fh,	0Ah, 3Fh
		db 9, 3Fh, 9, 3Fh, 8, 40h, 7, 40h, 6, 40h, 5, 40h, 5, 40h
		db 4, 40h, 3, 40h, 2, 40h, 2, 40h, 1, 40h, 0, 40h, 0FFh
		db 40h,	0FEh, 40h, 0FEh, 40h, 0FDh, 40h, 0FCh, 40h, 0FBh
		db 40h,	0FBh, 40h, 0FAh, 40h, 0F9h, 40h, 0F8h, 40h, 0F7h
		db 3Fh,	0F7h, 3Fh, 0F6h, 3Fh, 0F5h, 3Fh, 0F4h, 3Fh, 0F4h
		db 3Fh,	0F3h, 3Fh, 0F2h, 3Eh
PSG3_SFX_Struct:db 0F1h, 3Eh, 0F0h, 3Eh, 0F0h, 3Eh, 0EFh, 3Eh, 0EEh, 3Dh
		db 0EDh, 3Dh, 0EDh, 3Dh, 0ECh, 3Dh, 0EBh, 3Dh, 0EAh, 3Ch
		db 0EAh, 3Ch, 0E9h, 3Ch, 0E8h, 3Bh, 0E8h, 3Bh, 0E7h, 3Bh
		db 0E6h, 3Bh, 0E5h, 3Ah, 0E5h, 3Ah, 0E4h, 3Ah, 0E3h, 39h
		db 0E3h, 39h, 0E2h, 38h, 0E1h, 38h, 0E0h, 38h, 0E0h, 37h
		db 0DFh, 37h, 0DEh, 36h, 0DEh, 36h, 0DDh, 36h, 0DCh, 35h
		db 0DCh, 35h, 0DBh, 34h, 0DBh, 34h, 0DAh, 33h, 0D9h, 33h
		db 0D9h, 32h, 0D8h, 32h, 0D7h, 31h, 0D7h, 31h, 0D6h, 30h
		db 0D6h, 30h, 0D5h, 2Fh
byte_1F7A:	db 0D4h				; DATA XREF: sub_95D+48w
						; sub_95D+A1r
u_RegisterByte:	db 2Fh				; DATA XREF: sub_95D+B3w
						; sub_95D+E3r
byte_1F7C:	db 0D4h				; DATA XREF: SetChannelVolume+95r
						; FlagE2_u_PSGEffect:loc_699w
u_KeyEventForYM:db 2Eh				; DATA XREF: SendChannelKeyEvent+Ar
						; sub_306+4w
		db 0D3h	; Ó
u_MusicBankOffset:db 2Eh			; DATA XREF: ROM:0073w
						; ROM:18E2o
ROM_Offset2:	db 0D3h, 2Dh, 0D2h		; DATA XREF: DoBankSwitch+2o
						; ROM:0076w
		db 2Dh
u_OffsetByte:	db 0D2h				; DATA XREF: ROM:00BBw
						; ROM:04A7w ...
u_OffsetByte2:	db 2Ch				; DATA XREF: ROM:00BEw
						; ROM:04B2w ...
		db 0D1h	; Ñ
		db  2Ch	; ,
		db 0D1h	; Ñ
		db  2Bh	; +
		db 0D0h	; Ð
		db  2Ah	; *
		db 0D0h	; Ð
		db  2Ah	; *
		db 0CFh	; Ï
		db  29h	; )
		db 0CFh	; Ï
		db  29h	; )
		db 0CEh	; Î
		db  28h	; (
		db 0CEh	; Î
		db  27h	; '
		db 0CDh	; Í
		db  27h	; '
		db 0CDh	; Í
		db  26h	; &
		db 0CCh	; Ì
		db  25h	; %
		db 0CCh	; Ì
		db  25h	; %
		db 0CBh	; Ë
		db  24h	; $
		db 0CBh	; Ë
		db  24h	; $
		db 0CAh	; Ê
		db  23h	; #
		db 0CAh	; Ê
		db  22h	; "
		db 0CAh	; Ê
		db  22h	; "
		db 0C9h	; É
		db  21h	; !
		db 0C9h	; É
		db  20h
		db 0C8h	; È
		db  20h
		db 0C8h	; È
		db  1Fh
		db 0C8h	; È
		db  1Eh
		db 0C7h	; Ç
		db  1Dh
		db 0C7h	; Ç
		db  1Dh
		db 0C6h	; Æ
		db  1Ch
		db 0C6h	; Æ
		db  1Bh
		db 0C6h	; Æ
		db  1Bh
		db 0C5h	; Å
		db  1Ah
		db 0C5h	; Å
		db  19h
		db 0C5h	; Å
		db  18h
		db 0C5h	; Å
		db  18h
		db 0C4h	; Ä
		db  17h
		db 0C4h	; Ä
		db  16h
		db 0C4h	; Ä
		db  16h
		db 0C3h	; Ã
		db  15h
		db 0C3h	; Ã
		db  14h
		db 0C3h	; Ã
		db  13h
		db 0C3h	; Ã
		db  13h
		db 0C3h	; Ã
		db  12h
		db 0C2h	; Â
		db  11h
		db 0C2h	; Â
		db  10h
		db 0C2h	; Â
		db  10h
		db 0C2h	; Â
		db  0Fh
		db 0C2h	; Â
		db  0Eh
		db 0C1h	; Á
		db  0Dh
		db 0C1h	; Á
		db  0Ch
		db 0C1h	; Á
		db  0Ch
		db 0C1h	; Á
		db  0Bh
		db 0C1h	; Á
		db  0Ah
		db 0C1h	; Á
		db    9
		db 0C1h	; Á
		db    9
		db 0C0h	; À
		db    8
		db 0C0h	; À
		db    7
		db 0C0h	; À
		db    6
		db 0C0h	; À
		db    5
		db 0C0h	; À
		db    5
		db 0C0h	; À
		db    4
		db 0C0h	; À
		db    3
		db 0C0h	; À
		db    2
		db 0C0h	; À
		db    2
		db 0C0h	; À
		db    1
Stack:		ds 2000h			; DATA XREF: ROM:003Fo
YM_Port0_Reg:	ds 1				; DATA XREF: PlayPCM+29w
						; Write_YM_Port0:loc_4BFr ...
YM_Port0_Val:	ds 1				; DATA XREF: PlayPCM+30w
						; Write_YM_Port0+14w
YM_Port1_Reg:	ds 1				; DATA XREF: Write_YM_Port1+Ew
YM_Port1_Val:	ds 1				; DATA XREF: Write_YM_Port1+14w
byte_4004:	ds 1FFCh
BankRegister:	ds 1				; DATA XREF: ROM:0044w
						; ROM:0047w ...
		ds 1F10h
PSG_Port:	ds 1				; DATA XREF: InitPSG+5w
						; WritePSGData:WritePSGData_NoTestw ...
		ds 0EEh
ROMBank:	ds 8000h			; DATA XREF: ROM:0CFCo
; end of 'ROM'


		end
